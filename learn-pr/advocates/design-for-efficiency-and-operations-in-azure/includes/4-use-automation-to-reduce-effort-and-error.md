管理任何类型的工作负荷的基础结构涉及配置任务。 可以手动执行此配置, 但手动步骤可能会非常耗费人力、易出错且效率低下。 如果分配给需要在 Azure 上部署数百个系统的项目, 该怎么办？ 如何构建和配置这些资源？ 此操作需要多长时间？ 您能否确保每个系统都已正确配置, 无差异？ 通过在体系结构设计中使用自动化功能, 您可以解决这些难题。 让我们看一下你可以在 Azure 上实现自动化的一些方法。

## <a name="infrastructure-as-code"></a>作为代码的基础结构

作为代码的基础结构是一个描述性模型中的基础结构 (网络、虚拟机、负载平衡器和连接拓扑) 的管理, 使用的版本控制系统与用于源代码的版本类似。 与相同的源代码生成相同二进制文件的原则一样, IaC 模型会在每次应用它时生成相同的环境。 IaC 是一项关键 DevOps 实践, 通常与连续交付一起使用。

作为代码发展的基础结构, 以解决环境偏差问题。 如果没有 IaC, 团队必须维护各个部署环境的设置。 随着时间的推移, 每个环境将成为雪花, 即不能自动重现的唯一配置。 环境之间的不一致会导致部署过程中出现问题。 通过 snowflakes, 基础结构的管理和维护涉及难以跟踪和对错误进行贡献的手动过程。

自动化服务和基础结构的部署时, 可以采用两种不同的方法: 命令式和声明性。 在命令性方法中, 显式声明为生成要查找的结果所执行的命令。 使用声明性方法, 可以指定您希望结果的结果, 而不是指定您希望的结果的完成方式。 这两种方法都很有用, 因此没有任何错误的选择。 在 Azure 上, 这些不同的方法看起来是什么, 以及如何使用它们呢？

### <a name="imperative-automation"></a>命令性自动化

让我们从命令性自动化开始。 使用命令性自动化时, 我们将指定_如何_完成操作。 这通常通过脚本语言或 SDK 以编程方式完成。 对于 azure 资源, 我们可以使用 azure CLI 或 azure PowerShell。 我们来看一个使用 Azure CLI 创建存储帐户的示例。

```azure-cli
az group create --name storage-resource-group \
        --location eastus

az storage account create --name mystorageaccount \
        --resource-group storage-resource-group \
        --kind BlobStorage \
        --access-tier hot
```

在此示例中, 我们要指定如何创建这些资源。 执行命令以创建资源组。 执行另一个命令来创建存储帐户。 我们明确告诉 Azure 要运行哪些命令来生成所需的输出。

通过此方法, 我们能够完全自动化基础结构。 我们可以提供输入和输出的区域, 并可确保每次执行相同的命令。 通过自动化我们的资源, 我们已将手动步骤从过程中移出, 使资源管理的工作效率更高。 不过, 这种方法也有一些弊端。 在体系结构变得越来越复杂的情况中, 创建资源的脚本可能会迅速变得复杂。 可能需要添加错误处理和输入验证, 以确保完全执行。 命令可能会更改, 需要持续的脚本维护。

### <a name="declarative-automation"></a>声明性自动化

通过声明性自动化, 我们将__ 指定我们希望得到的结果, 并提供有关如何对正在使用的系统执行的详细信息。 在 azure 上, 声明性自动化通过使用 Azure 资源管理器模板来完成。

资源管理器模板是用于指定要创建的内容的 JSON 结构化文件。 在下面的示例中, 我们正在告诉 Azure 创建包含我们指定的名称和属性的存储帐户。 为创建此存储帐户而执行的实际步骤将保留给 Azure。 模板包含四个部分: 参数、变量、资源和输出。 参数处理要在模板中使用的输入。 变量提供了一种存储用于整个模板的值的方法。 资源是要创建的内容, 而产出是向已创建内容的用户提供详细信息的一种方式。

```json
{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "name": {
            "type": "string"
        },
        "location": {
            "type": "string"
        },
        "accountType": {
            "type": "string",
            "defaultValue": "Standard_RAGRS"
        },
        "kind": {
            "type": "string"
        },
        "accessTier": {
            "type": "string"
        },
        "httpsTrafficOnlyEnabled": {
            "type": "bool",
            "defaultValue": true
        }
    },
    "variables": {
    },
    "resources": [
        {
            "apiVersion": "2018-02-01",
            "name": "[parameters('name')]",
            "location": "[parameters('location')]",
            "type": "Microsoft.Storage/storageAccounts",
            "sku": {
                "name": "[parameters('accountType')]"
            },
            "kind": "[parameters('kind')]",
            "properties": {
                "supportsHttpsTrafficOnly": "[parameters('httpsTrafficOnlyEnabled')]",
                "accessTier": "[parameters('accessTier')]",
                "encryption": {
                    "services": {
                        "blob": {
                            "enabled": true
                        },
                        "file": {
                            "enabled": true
                        }
                    },
                    "keySource": "Microsoft.Storage"
                }
            },
            "dependsOn": []
        }
    ],
    "outputs": {
        "storageAccountName": {
            "type": "string",
            "value": "[parameters('name')]"
        }
    }
}
```

模板可用于在 Azure 上创建和操作大多数服务。 它们可以存储在代码库中并受源代码管理, 并在多个环境中共享, 以确保要开发的基础结构与实际生产中的内容相匹配。 它们是自动化部署并帮助确保一致性、消除部署错误配置并可提高运营速度的极好的方法。

自动化基础结构部署是一项极好的第一步, 但在部署虚拟机时, 仍有更多的工作要做。 我们来看看几种自动化配置部署的方法。

## <a name="vm-customization-images-vs-post-deployment-configuration"></a>VM 自定义: 图像与后期部署配置

对于许多虚拟机部署, 该作业不是在计算机运行时执行的。 在 VM 实际为其预期目的提供服务之前, 可能需要进行额外的配置。 其他磁盘可能需要格式化, VM 可能需要加入域, 或许需要安装管理软件的代理, 并且大多数情况下, 实际工作负载也需要安装和配置。

有两个通用策略适用于被认为是 VM 本身配置的配置工作, 这两者都有各自的优势和缺点:

- 自定义图像
- 部署后脚本

自定义图像是通过部署虚拟机, 然后在该运行实例上配置或安装软件生成的。 当一切配置正确时, 可以关闭计算机, 并从 VM 创建映像。 然后, 可以将该映像用作其他新虚拟机的基础。 使用自定义图像可以加快部署的总时间, 就像部署了虚拟机并运行后, 不需要其他配置。 如果部署速度是一个重要因素, 则自定义图像确实值得研究。

部署后脚本通常利用基本的基本映像, 然后依赖脚本或配置管理平台在部署 VM 之后进行配置。 可以通过 Azure 脚本扩展在 VM 上执行脚本, 或利用更强健的解决方案 (如 Azure 自动化所需的状态配置 (DSC)) 来完成部署后脚本。

每种方法都有一些需要注意的事项。 使用图像时, 需要确保有一个处理图像更新、安全修补程序和图像本身的库存管理的过程。 通过部署后脚本, 可以扩展生成时间, 因为在生成完成之前无法将 VM 添加到实时工作负荷。 这可能不是独立系统的重要问题, 但在使用自动缩放 (如虚拟机扩展集) 的服务时, 这种扩展的生成时间可能会影响您可以扩展的速度。 对于这两种方法, 您都需要确保解决配置偏移;随着新配置的推出, 您需要确保现有系统会相应地进行更新。

自动化资源部署对您的环境来说可能是一个巨大的好处。 保存的时间量和减少的错误可以将操作功能移到另一个级别。

## <a name="automation-of-operational-tasks"></a>操作任务的自动化

在你的解决方案正常运行后, 还可以进行自动化的日常操作活动。 使用 Azure 自动化自动执行这些任务可以减少手动工作负载, 启用对计算资源的配置和更新管理, 集中共享资源 (如计划、凭据和证书), 并提供用于运行任何Azure 任务的类型。

对于 Lamna 保健工作, 这可能包括:

- 定期搜索孤立磁盘。
- 在 vm 上安装最新的安全修补程序。
- 在非工作时间搜索和关闭虚拟机。
- 运行每日报告并生成仪表板, 以向高级管理层报告。

作为一个具体示例, 假设您只希望在营业时间运行虚拟机。 您可以编写脚本以在上午启动 VM 并在晚间关闭它。 您可以将 Azure 自动化配置为在设置时间运行脚本。 下图显示了此过程中 Azure 自动化的角色。

![展示了 Azure 自动化在管理重复业务流程中的角色的图示。](../media/automation-vm-power-state.png)

## <a name="automating-development-environments"></a>自动化开发环境

在云基础结构的管道的另一端, 开发人员使用开发计算机来编写作为业务核心的应用程序和服务。 您可以使用 Azure DevTest 实验室, 通过所需的所有正确工具和存储库来标记虚拟机。 使用多个服务的开发人员可以在开发环境之间进行切换, 而无需自行预配一台新计算机。 这些开发环境可以在未使用时关闭, 并在需要时重新启动。

## <a name="automation-at-lamna-healthcare"></a>Lamna 保健中的自动化

让我们来看看 Lamna 保健如何通过自动化进行改进。 当您开始旅程时, 基础结构部署和服务器生成都是完全手动完成的。 工程师通过门户部署所有内容。 这就是在测试和生产环境之间引入差异和错误, 而不同之处在于无法在代码命中率前检测问题的能力。

他们现在通过资源管理器模板部署所有基础结构。 这些模板将签入 GitHub 存储库, 并在发布以进行部署之前发生代码评审。 他们还可以在开发、测试和生产之间构建相同的基础结构, 以确保他们已在所有环境中验证其配置。

对于使用虚拟机的大多数服务, 它们都有一个标准的基本映像, 并使用 DSC 配置部署后的系统。 对于需要虚拟机规模集的可伸缩性的 web 场, 它们具有一个完全自动化的过程, 可用于签入代码并使用内置的所有必需配置生成新图像, 然后使其在其规模集中可用。

他们有一个自动化作业, 用于在非工作时间内关闭已确定的虚拟机, 以降低成本并使其 VM 也自动进行修补。

现在, 开发人员在 DevTest 实验室中有一个自助服务环境, 他们可以在其中针对最新的图像和配置进行开发, 以确保它们的开发内容与生产中的配置相匹配。

所有这些都是提前完成的, 但在长期运行中, 这些好处已得到支付。 他们极大地减少了错误, 以及他们的运营团队在维护其环境时所需付出的努力。 开发人员喜欢他们可以轻松地设置要开发的资源, 从而消除前后的以获取所创建的环境。

## <a name="summary"></a>摘要

我们已经介绍了多种将自动化功能引入体系结构的方法。 从将基础结构部署为代码, 以使用实验室环境提高开发人员的工作效率, 可以利用大量的时间来自动执行环境。 减少错误、降低差异并节省运营成本对组织而言是一项显著的好处, 可帮助将云环境转到下一级别。