<span data-ttu-id="61f3e-101">为了帮助确定无服务器计算是否适合您, 我们首先要了解什么是无服务器的。</span><span class="sxs-lookup"><span data-stu-id="61f3e-101">To help decide whether serverless computing is right for you, let's first learn what serverless is all about.</span></span>

## <a name="what-is-serverless-compute"></a><span data-ttu-id="61f3e-102">什么是无服务器计算？</span><span class="sxs-lookup"><span data-stu-id="61f3e-102">What is serverless compute?</span></span>

<span data-ttu-id="61f3e-103">无服务器计算可视为服务 (FaaS) 或云平台上承载的 microservice 的功能。</span><span class="sxs-lookup"><span data-stu-id="61f3e-103">Serverless compute can be thought of as a function as a service (FaaS), or a microservice that is hosted on a cloud platform.</span></span> <span data-ttu-id="61f3e-104">您的业务逻辑作为函数运行, 无需手动设置或扩展基础结构。</span><span class="sxs-lookup"><span data-stu-id="61f3e-104">Your business logic runs as functions and you don't have to manually provision or scale infrastructure.</span></span> <span data-ttu-id="61f3e-105">云提供程序管理基础结构。</span><span class="sxs-lookup"><span data-stu-id="61f3e-105">The cloud provider manages infrastructure.</span></span> <span data-ttu-id="61f3e-106">您的应用程序将根据负载自动缩小或停机。</span><span class="sxs-lookup"><span data-stu-id="61f3e-106">Your app is automatically scaled out or down depending on load.</span></span> <span data-ttu-id="61f3e-107">Azure 有几种生成此类体系结构的方法。</span><span class="sxs-lookup"><span data-stu-id="61f3e-107">Azure has several ways to build this sort of architecture.</span></span> <span data-ttu-id="61f3e-108">两种最常见的方法是 azure 逻辑应用和 azure 函数, 我们将重点放在本模块中。</span><span class="sxs-lookup"><span data-stu-id="61f3e-108">The two most common approaches are Azure Logic Apps and Azure Functions, which we focus on in this module.</span></span>

## <a name="what-is-azure-functions"></a><span data-ttu-id="61f3e-109">什么是 Azure 函数？</span><span class="sxs-lookup"><span data-stu-id="61f3e-109">What is Azure Functions?</span></span>

<span data-ttu-id="61f3e-110">Azure 函数是一个无服务器应用程序平台。</span><span class="sxs-lookup"><span data-stu-id="61f3e-110">Azure Functions is a serverless application platform.</span></span> <span data-ttu-id="61f3e-111">它使开发人员能够在不设置基础结构的情况下托管可执行的业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="61f3e-111">It allows developers to host business logic that can be executed without provisioning infrastructure.</span></span> <span data-ttu-id="61f3e-112">函数提供了固有的可伸缩性, 仅对所使用的资源计费。</span><span class="sxs-lookup"><span data-stu-id="61f3e-112">Functions provides intrinsic scalability and you are charged only for the resources used.</span></span> <span data-ttu-id="61f3e-113">您可以编写您选择的语言的函数代码, 包括 c #、F # 和 JavaScript。</span><span class="sxs-lookup"><span data-stu-id="61f3e-113">You can write your function code in the language of your choice, including C#, F#, and JavaScript.</span></span> <span data-ttu-id="61f3e-114">此外, 还包括对 NuGet 和 NPM 的支持, 因此您可以在业务逻辑中使用常用库。</span><span class="sxs-lookup"><span data-stu-id="61f3e-114">Support for NuGet and NPM is also included, so you can use popular libraries in your business logic.</span></span>

## <a name="benefits-of-a-serverless-compute-solution"></a><span data-ttu-id="61f3e-115">无服务器计算解决方案的好处</span><span class="sxs-lookup"><span data-stu-id="61f3e-115">Benefits of a serverless compute solution</span></span>

<span data-ttu-id="61f3e-116">无服务器计算是在云中托管业务逻辑代码的一个极好的选择。</span><span class="sxs-lookup"><span data-stu-id="61f3e-116">Serverless compute is a great option for hosting business logic code in the cloud.</span></span> <span data-ttu-id="61f3e-117">使用 Azure 函数等无服务器产品, 您可以使用您选择的语言编写业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="61f3e-117">With serverless offerings such as Azure Functions, you can write your business logic in the language of your choice.</span></span> <span data-ttu-id="61f3e-118">您可以进行自动缩放, 无需管理服务器, 而是根据所使用的内容收费, 而不是保留时间。</span><span class="sxs-lookup"><span data-stu-id="61f3e-118">You get automatic scaling, you have no servers to manage, and you are charged based on what is used — not on reserved time.</span></span> <span data-ttu-id="61f3e-119">下面是可供您考虑的无服务器解决方案的一些附加特征。</span><span class="sxs-lookup"><span data-stu-id="61f3e-119">Here are some additional characteristics of a serverless solution for you to consider.</span></span>

### <a name="avoids-over-allocation-of-infrastructure"></a><span data-ttu-id="61f3e-120">避免基础结构的过度分配</span><span class="sxs-lookup"><span data-stu-id="61f3e-120">Avoids over-allocation of infrastructure</span></span>

<span data-ttu-id="61f3e-121">假设您已设置了 VM 服务器, 并配置了足够的资源来处理峰值负载时间。</span><span class="sxs-lookup"><span data-stu-id="61f3e-121">Suppose you've provisioned VM servers and configured them with enough resources to handle your peak load times.</span></span> <span data-ttu-id="61f3e-122">当负载较亮时, 您可能会为未使用的基础结构付费。</span><span class="sxs-lookup"><span data-stu-id="61f3e-122">When the load is light, you are potentially paying for infrastructure you're not using.</span></span> <span data-ttu-id="61f3e-123">无服务器计算可通过自动向上或向下扩展来解决分配问题, 并且只有在函数处理工作时才会向您收取费用。</span><span class="sxs-lookup"><span data-stu-id="61f3e-123">Serverless computing helps solve the allocation problem by scaling up or down automatically, and you're only billed when your function is processing work.</span></span>

### <a name="stateless-logic"></a><span data-ttu-id="61f3e-124">无状态逻辑</span><span class="sxs-lookup"><span data-stu-id="61f3e-124">Stateless logic</span></span>

<span data-ttu-id="61f3e-125">无状态函数是无服务器计算的理想候选项;根据需要创建和销毁函数实例。</span><span class="sxs-lookup"><span data-stu-id="61f3e-125">Stateless functions are great candidates for serverless compute; function instances are created and destroyed on demand.</span></span> <span data-ttu-id="61f3e-126">如果 state 是必需的, 则可以将其存储在关联的存储服务中。</span><span class="sxs-lookup"><span data-stu-id="61f3e-126">If state is required, it can be stored in an associated storage service.</span></span>

### <a name="event-driven"></a><span data-ttu-id="61f3e-127">事件驱动</span><span class="sxs-lookup"><span data-stu-id="61f3e-127">Event driven</span></span>

<span data-ttu-id="61f3e-128">函数是_事件驱动_的。</span><span class="sxs-lookup"><span data-stu-id="61f3e-128">Functions are _event driven_.</span></span> <span data-ttu-id="61f3e-129">这意味着它们仅在响应事件 (称为 "触发器") 时运行, 例如接收 HTTP 请求或添加到队列中的邮件。</span><span class="sxs-lookup"><span data-stu-id="61f3e-129">This means they run only in response to an event (called a "trigger"), such as receiving an HTTP request, or a message being added to a queue.</span></span> <span data-ttu-id="61f3e-130">将触发器配置为函数定义的一部分。</span><span class="sxs-lookup"><span data-stu-id="61f3e-130">You configure a trigger as part of the function definition.</span></span> <span data-ttu-id="61f3e-131">此方法使您可以声明数据来自何处 (触发器/输入绑定) 及其转到的位置 (输出绑定), 从而简化了代码。</span><span class="sxs-lookup"><span data-stu-id="61f3e-131">This approach simplifies your code by allowing you to declare where the data comes from (trigger/input binding) and where it goes (output binding).</span></span> <span data-ttu-id="61f3e-132">您无需编写代码来监视队列、blob、集线器等。您可以完全专注于业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="61f3e-132">You don't need to write code to watch queues, blobs, hubs, etc. You can focus purely on the business logic.</span></span>

### <a name="functions-can-be-used-in-traditional-compute-environments"></a><span data-ttu-id="61f3e-133">函数可在传统计算环境中使用</span><span class="sxs-lookup"><span data-stu-id="61f3e-133">Functions can be used in traditional compute environments</span></span>

<span data-ttu-id="61f3e-134">函数是无服务器计算的关键组件, 但它们也是用于执行任何类型的代码的常规计算平台。</span><span class="sxs-lookup"><span data-stu-id="61f3e-134">Functions are a key component of serverless computing, but they are also a general compute platform for executing any type of code.</span></span> <span data-ttu-id="61f3e-135">如果应用程序的需要发生变化, 则可以获取项目并将其部署到非无服务器环境中, 这使您可以灵活地管理扩展、在虚拟网络上运行, 甚至完全隔离您的功能。</span><span class="sxs-lookup"><span data-stu-id="61f3e-135">Should the needs of your app change, you can take your project and deploy it in a non-serverless environment, which gives you the flexibility to manage scaling, run on virtual networks, and even completely isolate your functions.</span></span>

## <a name="drawbacks-of-a-serverless-compute-solution"></a><span data-ttu-id="61f3e-136">无服务器计算解决方案的缺点</span><span class="sxs-lookup"><span data-stu-id="61f3e-136">Drawbacks of a serverless compute solution</span></span>

<span data-ttu-id="61f3e-137">无服务器计算在托管业务逻辑时不一定是合适的解决方案。</span><span class="sxs-lookup"><span data-stu-id="61f3e-137">Serverless compute will not always be the appropriate solution to hosting your business logic.</span></span> <span data-ttu-id="61f3e-138">下面列出了一些函数特征, 这些特征可能会影响您在无服务器计算中托管服务的决策。</span><span class="sxs-lookup"><span data-stu-id="61f3e-138">Here are a few characteristics of functions that may affect your decision to host your services in serverless compute.</span></span>

### <a name="execution-time"></a><span data-ttu-id="61f3e-139">执行时间</span><span class="sxs-lookup"><span data-stu-id="61f3e-139">Execution time</span></span>

<span data-ttu-id="61f3e-140">默认情况下, 函数的超时值为5分钟。</span><span class="sxs-lookup"><span data-stu-id="61f3e-140">By default, functions have a timeout of 5 minutes.</span></span> <span data-ttu-id="61f3e-141">此超时可配置为最多10分钟。</span><span class="sxs-lookup"><span data-stu-id="61f3e-141">This timeout is configurable to a maximum of 10 minutes.</span></span> <span data-ttu-id="61f3e-142">如果您的函数需要10分钟以上才能执行, 则可以将其托管在 VM 上。</span><span class="sxs-lookup"><span data-stu-id="61f3e-142">If your function requires more than 10 minutes to execute, you can host it on a VM.</span></span> <span data-ttu-id="61f3e-143">此外, 如果您的服务是通过 HTTP 请求启动的, 并且您认为该值为 http 响应, 则超时将进一步限制为2.5 分钟。</span><span class="sxs-lookup"><span data-stu-id="61f3e-143">Additionally, if your service is initiated through an HTTP request and you expect that value as an HTTP response, the timeout is further restricted to 2.5 minutes.</span></span> <span data-ttu-id="61f3e-144">最后, 还提供了一个称为 "**耐用函数**" 的选项, 使您能够在不超时的情况下安排多个函数的执行。</span><span class="sxs-lookup"><span data-stu-id="61f3e-144">Finally, there's also an option called **Durable Functions** that allows you to orchestrate the executions of multiple functions without any timeout.</span></span>

### <a name="execution-frequency"></a><span data-ttu-id="61f3e-145">执行频率</span><span class="sxs-lookup"><span data-stu-id="61f3e-145">Execution frequency</span></span>

<span data-ttu-id="61f3e-146">第二个特征是执行频率。</span><span class="sxs-lookup"><span data-stu-id="61f3e-146">The second characteristic is execution frequency.</span></span> <span data-ttu-id="61f3e-147">如果您希望您的函数连续由多个客户端执行, 则应谨慎估计使用情况并计算使用函数的成本。</span><span class="sxs-lookup"><span data-stu-id="61f3e-147">If you expect your function to be executed continuously by multiple clients, it would be prudent to estimate the usage and calculate the cost of using functions accordingly.</span></span> <span data-ttu-id="61f3e-148">将服务托管在 VM 上可能会更便宜。</span><span class="sxs-lookup"><span data-stu-id="61f3e-148">It might be cheaper to host your service on a VM.</span></span>

<span data-ttu-id="61f3e-149">在缩放时, 每10秒只能创建一个 function 应用程序实例, 最多可创建200个实例。</span><span class="sxs-lookup"><span data-stu-id="61f3e-149">While scaling, only one function app instance can be created every 10 seconds, for up to 200 total instances.</span></span> <span data-ttu-id="61f3e-150">请记住, 每个实例都可以服务多个并发执行, 因此, 对于单个实例可以处理多少流量, 不会对流量设置限制。</span><span class="sxs-lookup"><span data-stu-id="61f3e-150">Keep in mind, each instance can service multiple concurrent executions, so there is no set limit on how much traffic a single instance can handle.</span></span> <span data-ttu-id="61f3e-151">不同类型的触发器具有不同的缩放要求, 因此, 请研究您选择的触发器并调查其限制。</span><span class="sxs-lookup"><span data-stu-id="61f3e-151">Different types of triggers have different scaling requirements, so research your choice of trigger and investigate its limits.</span></span>
