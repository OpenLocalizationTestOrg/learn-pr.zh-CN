在我们的最后一个练习中, 我们实施了一个在 Azure Cosmos DB 数据库中查找书签的方案。 我们配置了输入绑定以读取我们的书签集合中的数据。 但我们可以做更多的任务。 让我们展开应用场景以包括写作。 请考虑以下流程图:

![显示在我们的 Cosmos DB 后端中查找书签的过程的流程图。 当 Azure 函数接收到包含书签 id 的请求时, 它首先检查该请求是否有效, 如果不生成错误响应。 对于有效的请求, 函数将检查 Cosmos DB 中是否存在书签 id (如果不存在, 则会生成错误响应)。 如果找到了书签 id, 则会生成成功响应。](../media/7-add-bookmark-flow-small.png)

在这种情况下, 我们将收到向集合中添加书签的请求。 请求传入所需的注册表项或 ID, 以及书签 URL。 正如您在流程图中看到的那样, 如果后面的键已存在, 我们将会有错误回复。

如果找*不*到传递给我们的密钥, 我们会将新书签添加到数据库中。 我们可能会停止在这里, 但让我们做一些更多的操作。

请注意流程图中的另一个步骤？ 到目前为止, 我们还没有使用我们在处理方面收到的数据完成许多工作。 我们将收到的内容移动到数据库中。 但是, 在实际解决方案中, 我们可能会以某种方式处理数据。 我们可以决定在同一个函数中执行所有处理, 但在此实验中, 我们将显示一种模式, 用于减轻对另一个组件或业务逻辑的进一步处理。

在我们的书签方案中, 这可能是此工作分担的一个很棒的示例？ 如果我们将新书签发送到 QR 代码生成服务, 该怎么办？ 然后, 该服务会为 URL 生成 QR 代码, 将该图像存储在 blob 存储中, 并将 QR 图像的地址添加回我们的书签集合中的条目。 调用服务以生成 QR 图像是非常耗时的, 而不是等待结果, 而是将其交给某个函数, 让它以异步方式执行此操作。

就像 Azure 函数支持各种集成源的输入绑定一样, 它还具有一组输出绑定模板, 使您可以轻松地将数据写入数据源。 输出绑定也在*函数 json*文件中进行配置。  正如您在本练习中看到的那样, 我们可以将函数配置为使用多个数据源和服务。

> [!IMPORTANT]
> 本练习将在上一步中构建。 它使用相同的 Azure Cosmos DB 数据库和输入绑定。 如果尚未通过该设备, 我们建议您在继续执行此操作之前执行此操作。

## <a name="create-an-http-triggered-function"></a>创建 HTTP 触发的函数

1. 请确保使用随激活沙盒的相同帐户登录到[Azure 门户](https://portal.azure.com/learn.docs.microsoft.com?azure-portal=true)。

2. 在门户中, 导航到您在此模块中创建的函数应用程序。

3. 选择 "函数"**+** 旁边的 "添加****" () 按钮。 此操作将启动函数创建过程。 
4. 页面向我们显示一组当前支持的触发器。 选择 " **HTTP 触发器**"。

5. 使用以下值填写在右侧显示的 "**新建函数**" 窗格:

    |Field  |值  |
    |---------|---------|
    |名称     |   [!INCLUDE [func-name-add](./func-name-add.md)]     |
    | 授权级别 | **函数** |

6. 选择 "**创建**" 以创建函数。 此操作将在代码编辑器中打开该 **.js**文件, 并显示 HTTP 触发的函数的默认实现。

## <a name="add-an-azure-cosmos-db-input-binding"></a>添加 Azure Cosmos DB 输入绑定

让我们在前面的模块中重复操作, 以添加 Azure Cosmos DB 输入绑定。

1. 请确保在 "函数" [!INCLUDE [func-name-add](./func-name-add.md)]列表中选择了 "新函数"。 
1. 在左窗格中选择 "**集成**" 以打开 "集成" 选项卡。
   
1. 在 "**输入**" 列中选择 "**新建输入**", 以显示所有可能的输入绑定类型的列表。

1. 依次选择列表中的 " **Azure Cosmos DB** " 和 "**选择**"。
1. 如果出现一条消息, 要求您安装 CosmosDB 扩展名, 请选择 "**安装**并等待其完成"。 
 1. 在 " **Azure Cosmos DB 帐户连接**" 字段中, 选择 "**新建**"。
   此操作将打开 "**连接**" 对话框。 选择您的订阅和数据库帐户, 然后选择 "**选择**"。 

1. 已配置与数据库的新连接, 并显示在 " **Azure Cosmos DB 帐户连接**" 字段中。 如果您想了解此抽象名称的实际背后的内容, 请单击 "*显示值*" 以显示连接字符串。

您想要查找具有特定 ID 的书签, 让我们将接收到的 id 与绑定的 id 关联起来。

1. 在 "**文档 ID (可选)** " 字段中`{id}`, 输入。 此语法称为*绑定表达式*。 此函数由 HTTP 请求触发, 该请求使用查询字符串指定要查找的 ID。 由于 id 在集合中是唯一的, 因此绑定将返回0个 (未找到) 或1个 (找到的) 文档。

1. 使用下表中的值仔细填写本页上的其余字段。 您可以随时单击每个字段名称右侧的信息图标, 以了解有关每个字段的用途的详细信息。

    |设置  |值  |说明  |
    |---------|---------|---------|
    |文档参数名称     |  **书签**       |  用于标识代码中的此绑定的名称。      |
    |数据库名称     |  [!INCLUDE [cosmos-db-name](./cosmos-db-name.md)]       | 要使用的数据库。 此值是我们在本课前面设置的数据库名称。        |
    |集合名称     |  [!INCLUDE [cosmos-db-name](./cosmos-coll-name.md)]        | 将从中读取数据的集合。 此设置是在本课前面的部分定义的。 |
    |SQL 查询 (可选)    |   保留为空       |   我们仅基于 ID 在一次检索一个文档。 因此, 使用 "文档 ID" 字段进行筛选比在此实例中使用 SQL 查询更好。 我们可以手工创建一个 SQL 查询, 以返回一个`SELECT * from b where b.ID = {id}`条目 ()。 该查询确实会返回一个文档, 但会将其返回到文档集合中。 我们的代码必须不必要地处理集合。 当您想要获取多个文档时, 请使用 SQL 查询方法。   |
    |分区键 (可选) | **号** |  在前面创建[!INCLUDE [cosmos-coll-name](./cosmos-coll-name.md)] Cosmos DB 集合时, 添加已定义的分区键。  此处输入的项 (在输入绑定格式`{<key>}`中指定) 必须与集合中的键相匹配。|

9. 选择 "**保存**" 以保存对此绑定配置所做的所有更改。

现在, 我们有一个 Azure Cosmos DB 输入绑定。 现在可以添加输出绑定, 因此我们可以将新条目写入我们的集合。  

## <a name="add-an-azure-cosmos-db-output-binding"></a>添加 Azure Cosmos DB 输出绑定

1. 确保在函数列表中[!INCLUDE [func-name-add](./func-name-add.md)]仍处于选中状态的函数。 
1. 在左窗格中选择 "**集成**" 以打开 "集成" 选项卡。
   
1. 在 "**输出**" 列中选择 "**新建输出**", 以显示所有可能的输出绑定类型的列表。

1. 在列表中选择 " **Azure Cosmos DB** ", 然后选择 "**选择**"。

1. **Azure Cosmos DB 帐户连接**字段应使用您在添加 Cosmos DB 输入绑定时创建的连接预先填充。  

1. 使用下表中的值仔细填写本页上的其余字段。 您可以随时单击每个字段名称右侧的信息图标, 以了解有关每个字段的用途的详细信息。

    |设置  |值  |说明  |
    |---------|---------|---------|
    |文档参数名称     |  **newbookmark**       |  用于标识代码中的此绑定的名称。 此参数用于写入新的书签条目。     |
    |数据库名称     |  [!INCLUDE [cosmos-db-name](./cosmos-db-name.md)]       | 要使用的数据库。 此值是我们在本课前面设置的数据库名称。        |
    |集合名称     |  [!INCLUDE [cosmos-db-name](./cosmos-coll-name.md)]        | 将从中读取数据的集合。 此设置是在本课前面的部分定义的。 |
    |分区键 (可选) | **号** |  在前面创建[!INCLUDE [cosmos-coll-name](./cosmos-coll-name.md)] Cosmos DB 集合时, 添加已定义的分区键。  此处输入的项 (在输入绑定格式`{<key>}`中指定) 必须与集合中的键相匹配。 |
     |集合吞吐量 (可选)     |   保留为空      |  我们可以接受此处的默认值。       |

9. 选择 "**保存**" 以保存对此绑定配置所做的所有更改。

现在, 我们有一个绑定可从我们的集合中读取, 另一个是向其写入。 

## <a name="add-an-azure-queue-storage-output-binding"></a>添加 Azure 队列存储输出绑定

Azure 队列存储是一项用于存储可从世界各地访问的邮件的服务。 单个邮件的大小可以为 64 KB, 并且队列中包含的邮件&mdash;数可以达到定义的存储帐户总容量的多少。 下图显示了在我们的方案中如何使用队列的高级别:

![显示存储队列和两个函数一次推送并将其他弹出邮件发送到队列中的插图](../media/7-q-logical-small.png)

在这里, 您可以看到新函数, [!INCLUDE [func-name-add](./func-name-add.md)]将邮件添加到队列中。 另一个&mdash;函数例如, 名为 gen- *qr 码*&mdash;的假想函数将从同一队列中弹出消息, 并处理该请求。  从向队列中写入或*推送*邮件以来, 我们将[!INCLUDE [func-name-add](./func-name-add.md)]向您的解决方案中添加新的输出绑定。 现在, 让我们通过门户 UI 创建绑定。

1. 再次选择左侧函数菜单中的 "**集成**" 以打开 "集成" 选项卡。

1. 在 "**输出**" 列中选择 "**新输出**"。
    将显示所有可能的输出绑定类型的列表。

1. 在列表中, 选择 " **Azure 队列存储**", 然后选择 "**选择**"。
    此操作将打开 "Azure 队列存储输出配置" 页。

   接下来, 我们将设置存储帐户连接。 这是将托管队列的位置。
1. 如果出现一条消息, 要求您安装 Microsoft Azure web 作业扩展, 请选择 "**安装**并等待其完成"。 

4. 在 "**存储帐户连接**" 字段的右侧, 选择 "**新建**"。
   将打开 "**存储帐户**选择" 窗格。

5. 当我们启动此模块并创建了 function app 时, 也会在此时创建一个存储帐户。 它在此窗格中列出, 因此将其选中。 "**存储帐户连接**" 字段中填入了一个连接的名称。 如果要查看连接字符串值, 请选择 "**显示值**"。

6. 尽管我们可以保留所有其他字段中的默认值, 但让我们更改以下内容以更好地表示属性:

    |属性  |旧值  |新值  | 说明 |
    |---------|---------|---------|---------|
    |队列名称     |    outqueue     |  **书签-进程后**      | 放置书签的队列的名称, 以便其他函数可以对其进行进一步处理。 |
    | 消息参数名称    |  outputQueueItem       |   **newmessage**      | 我们将在代码中使用的绑定属性。 |

7. 请记住, 选择 "**保存**" 以保存所做的更改。

## <a name="update-function-implementation"></a>更新函数实现

现在, 我们已为该[!INCLUDE [func-name-add](./func-name-add.md)]函数设置了所有绑定。 现在是在函数中使用它们。

1.  选择函数 "" [!INCLUDE [func-name-add](./func-name-add.md)], 在代码编辑器中打开 " **index .js** " 文件。

2. 将*索引 .js*文件中的所有代码替换为以下代码段中的代码, 然后**保存**:

   [!code-javascript[](../code/add-bookmark.js)]

让我们分解一下此代码执行的操作:

* 由于此函数会更改数据, 因此, 我们预期 HTTP 请求是 POST, 并且书签数据是请求正文的一部分。
* 我们的 Azure Cosmos DB 输入绑定尝试使用我们收到的`id`来检索文档或书签。 如果找到了一个条目, 则`bookmark`将设置该对象。 `if(bookmark)`条件检查是否找到了条目。
* 将`context.bindings.newbookmark` binding 参数设置为新书签条目 (我们已将其创建为 JSON 字符串) 就像将 binding 参数添加到数据库中一样简单。
* 将邮件发送到队列就像设置`context.bindings.newmessage`参数一样简单。

> [!NOTE]
> 您执行的唯一任务是创建队列绑定。 您从未显式创建过队列。 您正在 witnessing 绑定的力量! 如以下标注所示, 如果不存在, 则自动为您创建队列。

![屏幕截图调出队列将自动创建。](../media/7-q-auto-create-small.png)

就是这样。 我们来看下一节中的工作在操作中。

## <a name="try-it-out"></a>试用

至此, 我们有多个输出绑定, 测试变得越来越棘手。 在以前的实验中, 我们通过发送 HTTP 请求和查询字符串来测试要测试的内容, 但现在我们想要执行 http post。 我们还需要检查邮件是否正在将其置于队列中。

1. 使用我们的函数[!INCLUDE [func-name-add](./func-name-add.md)], 在函数应用门户中选中, 选择最右侧的测试菜单项以将其展开。

2. 选择 "**测试**" 菜单项, 并验证是否已打开 "测试" 窗格。 下面的屏幕截图显示了它应如下所示:

    ![显示已展开的函数测试面板的屏幕截图。](../media/7-test-panel-open-small.png)

    > [!IMPORTANT]
    > 确保在 "HTTP 方法" 下拉列表中选择了 "**公告**"。

3. 将请求正文的内容替换为以下 JSON 有效负载:

    ```json
    {
        "id": "docs",
        "url": "https://docs.microsoft.com/azure"
    }
    ```

4. 选择 "测试" 窗格底部的 "**运行**"。

5. 验证 "**输出**" 窗口是否显示 "书签已存在" 消息, 如下图中所示:

    ![显示测试面板和失败的测试结果的屏幕截图。](../media/7-test-exists-small.png)

6. 将请求正文替换为以下有效负载:

    ```json
    {
        "id": "github",
        "url": "https://www.github.com"
    }
    ```
7. 选择 "测试" 窗格底部的 "**运行**"。

8. 验证 "*输出*" 框是否显示 "添加的书签" 消息, 如下图中所示。

    ![显示测试面板和成功测试结果的屏幕截图。](../media/7-test-success-small.png)

!! [!INCLUDE [func-name-add](./func-name-add.md)]工作方式如下所述, 但在代码中有哪些队列操作？ 好, 我们来看看是否有任何内容写入队列。

### <a name="verify-that-a-message-is-written-to-the-queue"></a>验证是否向队列中写入了邮件

Azure 队列存储队列托管在存储帐户中。 创建输出绑定时, 在本练习中已经选择了存储帐户。

1. 在 Azure 门户的主搜索框中, 键入 "**存储帐户**", 然后在 "**服务**" 下的 "结果" 列表中, 选择 "**存储帐户**"。

      ![在主搜索框中显示存储帐户的搜索结果的屏幕截图。](../media/7-search-for-sa-small.png)

2. 在返回的存储帐户列表中, 选择用于创建**newmessage**输出绑定的存储帐户。
   存储帐户设置将显示在门户的主窗口中。

3. 在 "**服务**" 列表中, 选择 "**队列**" 项目。
   将显示此存储帐户所承载的队列的列表。 验证**书签后**的 "书签" 队列是否存在, 如以下屏幕截图所示:

      ![在此存储帐户托管的队列列表中显示队列的屏幕截图](../media/7-q-in-list-small.png)

4. 选择 "**书签-进程后**" 以打开队列。
   队列中的邮件将显示在列表中。 如果所有内容都是按照计划进行的, 则队列包括您在向数据库添加书签时发布的消息。 其外观应如下所示:

    ![显示队列中的邮件的屏幕截图](../media/7-message-in-q-small.png)

   在此示例中, 您可以看到该邮件已被提供唯一 ID,**邮件文本**字段以 JSON 字符串格式显示您的书签。

5. 您可以通过在包含新 id/url 集和运行函数的 "测试" 窗格中更改请求正文来进一步测试该函数。 观看此队列以查看更多邮件到达。 您还可以查看数据库以验证是否已添加新条目。

在此实验中, 我们扩展了绑定到输出绑定的知识, 将数据写入 Azure Cosmos DB。 我们进一步执行并添加了另一个输出绑定, 以便将邮件发布到 Azure 队列。 这说明了绑定的真正威力, 可帮助您将数据从传入的源移动并移动到各种目标。 我们尚未编写任何数据库代码, 也不需要自己管理连接字符串。 相反, 我们以声明方式配置绑定, 并让平台处理连接的安全, 扩展我们的功能, 并扩展我们的连接。