<span data-ttu-id="5574d-101">在我们的最后一个练习中, 我们实施了一个在 Azure Cosmos DB 数据库中查找书签的方案。</span><span class="sxs-lookup"><span data-stu-id="5574d-101">In our last exercise, we implemented a scenario to look up bookmarks in an Azure Cosmos DB database.</span></span> <span data-ttu-id="5574d-102">我们配置了输入绑定以读取我们的书签集合中的数据。</span><span class="sxs-lookup"><span data-stu-id="5574d-102">We configured an input binding to read data from our bookmarks collection.</span></span> <span data-ttu-id="5574d-103">但我们可以做更多的任务。</span><span class="sxs-lookup"><span data-stu-id="5574d-103">But, we can do more.</span></span> <span data-ttu-id="5574d-104">让我们展开应用场景以包括写作。</span><span class="sxs-lookup"><span data-stu-id="5574d-104">Let's expand the scenario to include writing.</span></span> <span data-ttu-id="5574d-105">请考虑以下流程图:</span><span class="sxs-lookup"><span data-stu-id="5574d-105">Consider the following flowchart:</span></span>

![显示在我们的 Cosmos DB 后端中查找书签的过程的流程图。](../media/7-add-bookmark-flow-small.png)

<span data-ttu-id="5574d-110">在这种情况下, 我们将收到向集合中添加书签的请求。</span><span class="sxs-lookup"><span data-stu-id="5574d-110">In this scenario, we'll receive requests to add bookmarks to our collection.</span></span> <span data-ttu-id="5574d-111">请求传入所需的注册表项或 ID, 以及书签 URL。</span><span class="sxs-lookup"><span data-stu-id="5574d-111">The requests pass in the desired key, or ID, along with the bookmark URL.</span></span> <span data-ttu-id="5574d-112">正如您在流程图中看到的那样, 如果后面的键已存在, 我们将会有错误回复。</span><span class="sxs-lookup"><span data-stu-id="5574d-112">As you can see in the flowchart, we'll respond with an error if the key already exists in our back end.</span></span>

<span data-ttu-id="5574d-113">如果找*不*到传递给我们的密钥, 我们会将新书签添加到数据库中。</span><span class="sxs-lookup"><span data-stu-id="5574d-113">If the key that was passed to us is *not* found, we'll add the new bookmark to our database.</span></span> <span data-ttu-id="5574d-114">我们可能会停止在这里, 但让我们做一些更多的操作。</span><span class="sxs-lookup"><span data-stu-id="5574d-114">We could stop there, but let's do a little more.</span></span>

<span data-ttu-id="5574d-115">请注意流程图中的另一个步骤？</span><span class="sxs-lookup"><span data-stu-id="5574d-115">Notice another step in the flowchart?</span></span> <span data-ttu-id="5574d-116">到目前为止, 我们还没有使用我们在处理方面收到的数据完成许多工作。</span><span class="sxs-lookup"><span data-stu-id="5574d-116">So far we haven't done much with the data that we receive in terms of processing.</span></span> <span data-ttu-id="5574d-117">我们将收到的内容移动到数据库中。</span><span class="sxs-lookup"><span data-stu-id="5574d-117">We move what we receive into a database.</span></span> <span data-ttu-id="5574d-118">但是, 在实际解决方案中, 我们可能会以某种方式处理数据。</span><span class="sxs-lookup"><span data-stu-id="5574d-118">However, in a real solution, it is possible that we'd probably process the data in some fashion.</span></span> <span data-ttu-id="5574d-119">我们可以决定在同一个函数中执行所有处理, 但在此实验中, 我们将显示一种模式, 用于减轻对另一个组件或业务逻辑的进一步处理。</span><span class="sxs-lookup"><span data-stu-id="5574d-119">We can decide to do all processing in the same function, but in this lab we'll show a pattern that offloads further processing to another component or piece of business logic.</span></span>

<span data-ttu-id="5574d-120">在我们的书签方案中, 这可能是此工作分担的一个很棒的示例？</span><span class="sxs-lookup"><span data-stu-id="5574d-120">What might be a good example of this offloading of work in our bookmarks scenario?</span></span> <span data-ttu-id="5574d-121">如果我们将新书签发送到 QR 代码生成服务, 该怎么办？</span><span class="sxs-lookup"><span data-stu-id="5574d-121">Well, what if we send the new bookmark to a QR code generation service?</span></span> <span data-ttu-id="5574d-122">然后, 该服务会为 URL 生成 QR 代码, 将该图像存储在 blob 存储中, 并将 QR 图像的地址添加回我们的书签集合中的条目。</span><span class="sxs-lookup"><span data-stu-id="5574d-122">That service would, in turn, generate a QR code for the URL, store the image in blob storage, and add the address of the QR image back into the entry in our bookmarks collection.</span></span> <span data-ttu-id="5574d-123">调用服务以生成 QR 图像是非常耗时的, 而不是等待结果, 而是将其交给某个函数, 让它以异步方式执行此操作。</span><span class="sxs-lookup"><span data-stu-id="5574d-123">Calling a service to generate a QR image is time consuming so, rather than wait for the result, we hand it off to a function and let it take care of this asynchronously.</span></span>

<span data-ttu-id="5574d-124">就像 Azure 函数支持各种集成源的输入绑定一样, 它还具有一组输出绑定模板, 使您可以轻松地将数据写入数据源。</span><span class="sxs-lookup"><span data-stu-id="5574d-124">Just as Azure Functions supports input bindings for various integration sources, it also has a set of output bindings templates to make it easy for you to write data to data sources.</span></span> <span data-ttu-id="5574d-125">输出绑定也在*函数 json*文件中进行配置。</span><span class="sxs-lookup"><span data-stu-id="5574d-125">Output bindings are also configured in the *function.json* file.</span></span>  <span data-ttu-id="5574d-126">正如您在本练习中看到的那样, 我们可以将函数配置为使用多个数据源和服务。</span><span class="sxs-lookup"><span data-stu-id="5574d-126">As you'll see in this exercise, we can configure our function to work with multiple data sources and services.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5574d-127">本练习将在上一步中构建。</span><span class="sxs-lookup"><span data-stu-id="5574d-127">This exercise builds on the previous one.</span></span> <span data-ttu-id="5574d-128">它使用相同的 Azure Cosmos DB 数据库和输入绑定。</span><span class="sxs-lookup"><span data-stu-id="5574d-128">It uses the same Azure Cosmos DB database and input binding.</span></span> <span data-ttu-id="5574d-129">如果尚未通过该设备, 我们建议您在继续执行此操作之前执行此操作。</span><span class="sxs-lookup"><span data-stu-id="5574d-129">If you haven't worked through that unit, we recommend doing so before you proceed with this one.</span></span>

## <a name="create-an-http-triggered-function"></a><span data-ttu-id="5574d-130">创建 HTTP 触发的函数</span><span class="sxs-lookup"><span data-stu-id="5574d-130">Create an HTTP-triggered function</span></span>

1. <span data-ttu-id="5574d-131">请确保使用随激活沙盒的相同帐户登录到[Azure 门户](https://portal.azure.com/learn.docs.microsoft.com?azure-portal=true)。</span><span class="sxs-lookup"><span data-stu-id="5574d-131">Make sure you are signed into the [Azure portal](https://portal.azure.com/learn.docs.microsoft.com?azure-portal=true) using the same account you activated the sandbox with.</span></span>

2. <span data-ttu-id="5574d-132">在门户中, 导航到您在此模块中创建的函数应用程序。</span><span class="sxs-lookup"><span data-stu-id="5574d-132">In the portal, navigate to the function app that you created in this module.</span></span>

3. <span data-ttu-id="5574d-133">选择 "函数"**+** 旁边的 "添加\*\*\*\*" () 按钮。</span><span class="sxs-lookup"><span data-stu-id="5574d-133">Select the Add (**+**) button next to **Functions**.</span></span> <span data-ttu-id="5574d-134">此操作将启动函数创建过程。</span><span class="sxs-lookup"><span data-stu-id="5574d-134">This action starts the function creation process.</span></span> 
4. <span data-ttu-id="5574d-135">页面向我们显示一组当前支持的触发器。</span><span class="sxs-lookup"><span data-stu-id="5574d-135">The page shows us the current set of supported triggers.</span></span> <span data-ttu-id="5574d-136">选择 " **HTTP 触发器**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-136">Select **HTTP trigger**.</span></span>

5. <span data-ttu-id="5574d-137">使用以下值填写在右侧显示的 "**新建函数**" 窗格:</span><span class="sxs-lookup"><span data-stu-id="5574d-137">Fill out the **New Function** pane that's displayed at the right by using the following values:</span></span>

    |<span data-ttu-id="5574d-138">Field</span><span class="sxs-lookup"><span data-stu-id="5574d-138">Field</span></span>  |<span data-ttu-id="5574d-139">值</span><span class="sxs-lookup"><span data-stu-id="5574d-139">Value</span></span>  |
    |---------|---------|
    |<span data-ttu-id="5574d-140">名称</span><span class="sxs-lookup"><span data-stu-id="5574d-140">Name</span></span>     |   [!INCLUDE [func-name-add](./func-name-add.md)]     |
    | <span data-ttu-id="5574d-141">授权级别</span><span class="sxs-lookup"><span data-stu-id="5574d-141">Authorization level</span></span> | <span data-ttu-id="5574d-142">**函数**</span><span class="sxs-lookup"><span data-stu-id="5574d-142">**Function**</span></span> |

6. <span data-ttu-id="5574d-143">选择 "**创建**" 以创建函数。</span><span class="sxs-lookup"><span data-stu-id="5574d-143">Select **Create** to create your function.</span></span> <span data-ttu-id="5574d-144">此操作将在代码编辑器中打开该 **.js**文件, 并显示 HTTP 触发的函数的默认实现。</span><span class="sxs-lookup"><span data-stu-id="5574d-144">This action opens the **index.js** file in the code editor and displays a default implementation of the HTTP-triggered function.</span></span>

## <a name="add-an-azure-cosmos-db-input-binding"></a><span data-ttu-id="5574d-145">添加 Azure Cosmos DB 输入绑定</span><span class="sxs-lookup"><span data-stu-id="5574d-145">Add an Azure Cosmos DB input binding</span></span>

<span data-ttu-id="5574d-146">让我们在前面的模块中重复操作, 以添加 Azure Cosmos DB 输入绑定。</span><span class="sxs-lookup"><span data-stu-id="5574d-146">Let's repeat what we did in the preceding module to add an Azure Cosmos DB input binding.</span></span>

1. <span data-ttu-id="5574d-147">请确保在 "函数" [!INCLUDE [func-name-add](./func-name-add.md)]列表中选择了 "新函数"。</span><span class="sxs-lookup"><span data-stu-id="5574d-147">Make sure our new function, [!INCLUDE [func-name-add](./func-name-add.md)], is selected in the Functions list.</span></span> 
1. <span data-ttu-id="5574d-148">在左窗格中选择 "**集成**" 以打开 "集成" 选项卡。</span><span class="sxs-lookup"><span data-stu-id="5574d-148">Select **Integrate** in the left pane to open the integration tab.</span></span>
   
1. <span data-ttu-id="5574d-149">在 "**输入**" 列中选择 "**新建输入**", 以显示所有可能的输入绑定类型的列表。</span><span class="sxs-lookup"><span data-stu-id="5574d-149">Select **New Input** in the **Inputs** column to display the list of all possible input binding types.</span></span>

1. <span data-ttu-id="5574d-150">依次选择列表中的 " **Azure Cosmos DB** " 和 "**选择**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-150">Select **Azure Cosmos DB** in the list, followed by **Select**.</span></span>
1. <span data-ttu-id="5574d-151">如果出现一条消息, 要求您安装 CosmosDB 扩展名, 请选择 "**安装**并等待其完成"。</span><span class="sxs-lookup"><span data-stu-id="5574d-151">If a message appears asking  you to install the Microsoft.Azure.WebJobs.Extensions.CosmosDB extension, select **install** and wait for it to finish.</span></span> 
 1. <span data-ttu-id="5574d-152">在 " **Azure Cosmos DB 帐户连接**" 字段中, 选择 "**新建**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-152">In the  **Azure Cosmos DB account connection** field, select **new**.</span></span>
   <span data-ttu-id="5574d-153">此操作将打开 "**连接**" 对话框。</span><span class="sxs-lookup"><span data-stu-id="5574d-153">This action opens the **Connection** dialog.</span></span> <span data-ttu-id="5574d-154">选择您的订阅和数据库帐户, 然后选择 "**选择**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-154">Select your subscription and database account and then choose **Select**.</span></span> 

1. <span data-ttu-id="5574d-155">已配置与数据库的新连接, 并显示在 " **Azure Cosmos DB 帐户连接**" 字段中。</span><span class="sxs-lookup"><span data-stu-id="5574d-155">A new connection to the database is configured and is shown in the **Azure Cosmos DB account connection** field.</span></span> <span data-ttu-id="5574d-156">如果您想了解此抽象名称的实际背后的内容, 请单击 "*显示值*" 以显示连接字符串。</span><span class="sxs-lookup"><span data-stu-id="5574d-156">If you're curious about what is actually behind this abstract name, click *show value* to reveal the connection string.</span></span>

<span data-ttu-id="5574d-157">您想要查找具有特定 ID 的书签, 让我们将接收到的 id 与绑定的 id 关联起来。</span><span class="sxs-lookup"><span data-stu-id="5574d-157">You want to look up a bookmark with a specific ID, so let's tie the ID we receive to the binding.</span></span>

1. <span data-ttu-id="5574d-158">在 "**文档 ID (可选)** " 字段中`{id}`, 输入。</span><span class="sxs-lookup"><span data-stu-id="5574d-158">In the **Document ID (optional)** field, enter `{id}`.</span></span> <span data-ttu-id="5574d-159">此语法称为*绑定表达式*。</span><span class="sxs-lookup"><span data-stu-id="5574d-159">This syntax is known as a *binding expression*.</span></span> <span data-ttu-id="5574d-160">此函数由 HTTP 请求触发, 该请求使用查询字符串指定要查找的 ID。</span><span class="sxs-lookup"><span data-stu-id="5574d-160">The function is triggered by an HTTP request that uses a query string to specify the ID to look up.</span></span> <span data-ttu-id="5574d-161">由于 id 在集合中是唯一的, 因此绑定将返回0个 (未找到) 或1个 (找到的) 文档。</span><span class="sxs-lookup"><span data-stu-id="5574d-161">Since IDs are unique in our collection, the binding will return either 0 (not found) or 1 (found) documents.</span></span>

1. <span data-ttu-id="5574d-162">使用下表中的值仔细填写本页上的其余字段。</span><span class="sxs-lookup"><span data-stu-id="5574d-162">Carefully fill out the remaining fields on this page using the values in the following table.</span></span> <span data-ttu-id="5574d-163">您可以随时单击每个字段名称右侧的信息图标, 以了解有关每个字段的用途的详细信息。</span><span class="sxs-lookup"><span data-stu-id="5574d-163">At any time, you can click on the information icon to the right of each field name to learn more about the purpose of each field.</span></span>

    |<span data-ttu-id="5574d-164">设置</span><span class="sxs-lookup"><span data-stu-id="5574d-164">Setting</span></span>  |<span data-ttu-id="5574d-165">值</span><span class="sxs-lookup"><span data-stu-id="5574d-165">Value</span></span>  |<span data-ttu-id="5574d-166">说明</span><span class="sxs-lookup"><span data-stu-id="5574d-166">Description</span></span>  |
    |---------|---------|---------|
    |<span data-ttu-id="5574d-167">文档参数名称</span><span class="sxs-lookup"><span data-stu-id="5574d-167">Document parameter name</span></span>     |  <span data-ttu-id="5574d-168">**书签**</span><span class="sxs-lookup"><span data-stu-id="5574d-168">**bookmark**</span></span>       |  <span data-ttu-id="5574d-169">用于标识代码中的此绑定的名称。</span><span class="sxs-lookup"><span data-stu-id="5574d-169">The name used to identify this binding in your code.</span></span>      |
    |<span data-ttu-id="5574d-170">数据库名称</span><span class="sxs-lookup"><span data-stu-id="5574d-170">Database name</span></span>     |  [!INCLUDE [cosmos-db-name](./cosmos-db-name.md)]       | <span data-ttu-id="5574d-171">要使用的数据库。</span><span class="sxs-lookup"><span data-stu-id="5574d-171">The database to work with.</span></span> <span data-ttu-id="5574d-172">此值是我们在本课前面设置的数据库名称。</span><span class="sxs-lookup"><span data-stu-id="5574d-172">This value is the database name we set earlier in this lesson.</span></span>        |
    |<span data-ttu-id="5574d-173">集合名称</span><span class="sxs-lookup"><span data-stu-id="5574d-173">Collection Name</span></span>     |  [!INCLUDE [cosmos-db-name](./cosmos-coll-name.md)]        | <span data-ttu-id="5574d-174">将从中读取数据的集合。</span><span class="sxs-lookup"><span data-stu-id="5574d-174">The collection from which we'll read data.</span></span> <span data-ttu-id="5574d-175">此设置是在本课前面的部分定义的。</span><span class="sxs-lookup"><span data-stu-id="5574d-175">This setting was defined earlier in the lesson.</span></span> |
    |<span data-ttu-id="5574d-176">SQL 查询 (可选)</span><span class="sxs-lookup"><span data-stu-id="5574d-176">SQL Query (optional)</span></span>    |   <span data-ttu-id="5574d-177">保留为空</span><span class="sxs-lookup"><span data-stu-id="5574d-177">leave blank</span></span>       |   <span data-ttu-id="5574d-178">我们仅基于 ID 在一次检索一个文档。</span><span class="sxs-lookup"><span data-stu-id="5574d-178">We are only retrieving one document at a time based on the ID.</span></span> <span data-ttu-id="5574d-179">因此, 使用 "文档 ID" 字段进行筛选比在此实例中使用 SQL 查询更好。</span><span class="sxs-lookup"><span data-stu-id="5574d-179">So, filtering with the Document ID field is a better than using a SQL Query in this instance.</span></span> <span data-ttu-id="5574d-180">我们可以手工创建一个 SQL 查询, 以返回一个`SELECT * from b where b.ID = {id}`条目 ()。</span><span class="sxs-lookup"><span data-stu-id="5574d-180">We could craft a SQL Query to return one entry (`SELECT * from b where b.ID = {id}`).</span></span> <span data-ttu-id="5574d-181">该查询确实会返回一个文档, 但会将其返回到文档集合中。</span><span class="sxs-lookup"><span data-stu-id="5574d-181">That query would indeed return a document, but it would return it in a document collection.</span></span> <span data-ttu-id="5574d-182">我们的代码必须不必要地处理集合。</span><span class="sxs-lookup"><span data-stu-id="5574d-182">Our code would have to manipulate a collection unnecessarily.</span></span> <span data-ttu-id="5574d-183">当您想要获取多个文档时, 请使用 SQL 查询方法。</span><span class="sxs-lookup"><span data-stu-id="5574d-183">Use the SQL Query approach when you want to get multiple documents.</span></span>   |
    |<span data-ttu-id="5574d-184">分区键 (可选)</span><span class="sxs-lookup"><span data-stu-id="5574d-184">Partition key (optional)</span></span> | <span data-ttu-id="5574d-185">**号**</span><span class="sxs-lookup"><span data-stu-id="5574d-185">**{id}**</span></span> |  <span data-ttu-id="5574d-186">在前面创建[!INCLUDE [cosmos-coll-name](./cosmos-coll-name.md)] Cosmos DB 集合时, 添加已定义的分区键。</span><span class="sxs-lookup"><span data-stu-id="5574d-186">Add the partition key that we defined when we created the [!INCLUDE [cosmos-coll-name](./cosmos-coll-name.md)] Cosmos DB collection earlier.</span></span>  <span data-ttu-id="5574d-187">此处输入的项 (在输入绑定格式`{<key>}`中指定) 必须与集合中的键相匹配。</span><span class="sxs-lookup"><span data-stu-id="5574d-187">The key entered here (specified in input binding format `{<key>}`) must match the one in the collection.</span></span>|

9. <span data-ttu-id="5574d-188">选择 "**保存**" 以保存对此绑定配置所做的所有更改。</span><span class="sxs-lookup"><span data-stu-id="5574d-188">Select **Save** to save all changes to this binding configuration.</span></span>

<span data-ttu-id="5574d-189">现在, 我们有一个 Azure Cosmos DB 输入绑定。</span><span class="sxs-lookup"><span data-stu-id="5574d-189">We now have an Azure Cosmos DB input binding.</span></span> <span data-ttu-id="5574d-190">现在可以添加输出绑定, 因此我们可以将新条目写入我们的集合。</span><span class="sxs-lookup"><span data-stu-id="5574d-190">It's time to add an output binding so we can write new entries to our collection.</span></span>  

## <a name="add-an-azure-cosmos-db-output-binding"></a><span data-ttu-id="5574d-191">添加 Azure Cosmos DB 输出绑定</span><span class="sxs-lookup"><span data-stu-id="5574d-191">Add an Azure Cosmos DB output binding</span></span>

1. <span data-ttu-id="5574d-192">确保在函数列表中[!INCLUDE [func-name-add](./func-name-add.md)]仍处于选中状态的函数。</span><span class="sxs-lookup"><span data-stu-id="5574d-192">Make sure our function, [!INCLUDE [func-name-add](./func-name-add.md)], is still selected in the Functions list.</span></span> 
1. <span data-ttu-id="5574d-193">在左窗格中选择 "**集成**" 以打开 "集成" 选项卡。</span><span class="sxs-lookup"><span data-stu-id="5574d-193">Select **Integrate** in the left pane to open the integration tab.</span></span>
   
1. <span data-ttu-id="5574d-194">在 "**输出**" 列中选择 "**新建输出**", 以显示所有可能的输出绑定类型的列表。</span><span class="sxs-lookup"><span data-stu-id="5574d-194">Select **New Output** in the **Outputs** column to display the list of all possible output binding types.</span></span>

1. <span data-ttu-id="5574d-195">在列表中选择 " **Azure Cosmos DB** ", 然后选择 "**选择**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-195">Select **Azure Cosmos DB** in the list, and then choose **Select**.</span></span>

1. <span data-ttu-id="5574d-196">**Azure Cosmos DB 帐户连接**字段应使用您在添加 Cosmos DB 输入绑定时创建的连接预先填充。</span><span class="sxs-lookup"><span data-stu-id="5574d-196">The  **Azure Cosmos DB account connection** field should be pre-populated with the connection you created when you added the Cosmos DB input binding.</span></span>  

1. <span data-ttu-id="5574d-197">使用下表中的值仔细填写本页上的其余字段。</span><span class="sxs-lookup"><span data-stu-id="5574d-197">Carefully fill out the remaining fields on this page using the values in the following table.</span></span> <span data-ttu-id="5574d-198">您可以随时单击每个字段名称右侧的信息图标, 以了解有关每个字段的用途的详细信息。</span><span class="sxs-lookup"><span data-stu-id="5574d-198">At any time, you can click on the information icon to the right of each field name to learn more about the purpose of each field.</span></span>

    |<span data-ttu-id="5574d-199">设置</span><span class="sxs-lookup"><span data-stu-id="5574d-199">Setting</span></span>  |<span data-ttu-id="5574d-200">值</span><span class="sxs-lookup"><span data-stu-id="5574d-200">Value</span></span>  |<span data-ttu-id="5574d-201">说明</span><span class="sxs-lookup"><span data-stu-id="5574d-201">Description</span></span>  |
    |---------|---------|---------|
    |<span data-ttu-id="5574d-202">文档参数名称</span><span class="sxs-lookup"><span data-stu-id="5574d-202">Document parameter name</span></span>     |  <span data-ttu-id="5574d-203">**newbookmark**</span><span class="sxs-lookup"><span data-stu-id="5574d-203">**newbookmark**</span></span>       |  <span data-ttu-id="5574d-204">用于标识代码中的此绑定的名称。</span><span class="sxs-lookup"><span data-stu-id="5574d-204">The name used to identify this binding in your code.</span></span> <span data-ttu-id="5574d-205">此参数用于写入新的书签条目。</span><span class="sxs-lookup"><span data-stu-id="5574d-205">This parameter is used to write a new bookmark entry.</span></span>     |
    |<span data-ttu-id="5574d-206">数据库名称</span><span class="sxs-lookup"><span data-stu-id="5574d-206">Database name</span></span>     |  [!INCLUDE [cosmos-db-name](./cosmos-db-name.md)]       | <span data-ttu-id="5574d-207">要使用的数据库。</span><span class="sxs-lookup"><span data-stu-id="5574d-207">The database to work with.</span></span> <span data-ttu-id="5574d-208">此值是我们在本课前面设置的数据库名称。</span><span class="sxs-lookup"><span data-stu-id="5574d-208">This value is the database name we set earlier in this lesson.</span></span>        |
    |<span data-ttu-id="5574d-209">集合名称</span><span class="sxs-lookup"><span data-stu-id="5574d-209">Collection Name</span></span>     |  [!INCLUDE [cosmos-db-name](./cosmos-coll-name.md)]        | <span data-ttu-id="5574d-210">将从中读取数据的集合。</span><span class="sxs-lookup"><span data-stu-id="5574d-210">The collection from which we'll read data.</span></span> <span data-ttu-id="5574d-211">此设置是在本课前面的部分定义的。</span><span class="sxs-lookup"><span data-stu-id="5574d-211">This setting was defined earlier in the lesson.</span></span> |
    |<span data-ttu-id="5574d-212">分区键 (可选)</span><span class="sxs-lookup"><span data-stu-id="5574d-212">Partition key (optional)</span></span> | <span data-ttu-id="5574d-213">**号**</span><span class="sxs-lookup"><span data-stu-id="5574d-213">**{id}**</span></span> |  <span data-ttu-id="5574d-214">在前面创建[!INCLUDE [cosmos-coll-name](./cosmos-coll-name.md)] Cosmos DB 集合时, 添加已定义的分区键。</span><span class="sxs-lookup"><span data-stu-id="5574d-214">Add the partition key that we defined when we created the [!INCLUDE [cosmos-coll-name](./cosmos-coll-name.md)] Cosmos DB collection earlier.</span></span>  <span data-ttu-id="5574d-215">此处输入的项 (在输入绑定格式`{<key>}`中指定) 必须与集合中的键相匹配。</span><span class="sxs-lookup"><span data-stu-id="5574d-215">The key entered here (specified in input binding format `{<key>}`) must match the one in the collection.</span></span> |
     |<span data-ttu-id="5574d-216">集合吞吐量 (可选)</span><span class="sxs-lookup"><span data-stu-id="5574d-216">Collection throughput (optional)</span></span>     |   <span data-ttu-id="5574d-217">保留为空</span><span class="sxs-lookup"><span data-stu-id="5574d-217">leave blank</span></span>      |  <span data-ttu-id="5574d-218">我们可以接受此处的默认值。</span><span class="sxs-lookup"><span data-stu-id="5574d-218">We can accept the default here.</span></span>       |

9. <span data-ttu-id="5574d-219">选择 "**保存**" 以保存对此绑定配置所做的所有更改。</span><span class="sxs-lookup"><span data-stu-id="5574d-219">Select **Save** to save all changes to this binding configuration.</span></span>

<span data-ttu-id="5574d-220">现在, 我们有一个绑定可从我们的集合中读取, 另一个是向其写入。</span><span class="sxs-lookup"><span data-stu-id="5574d-220">Now we have a binding to read from our collection, and one to write to it.</span></span> 

## <a name="add-an-azure-queue-storage-output-binding"></a><span data-ttu-id="5574d-221">添加 Azure 队列存储输出绑定</span><span class="sxs-lookup"><span data-stu-id="5574d-221">Add an Azure Queue Storage output binding</span></span>

<span data-ttu-id="5574d-222">Azure 队列存储是一项用于存储可从世界各地访问的邮件的服务。</span><span class="sxs-lookup"><span data-stu-id="5574d-222">Azure Queue storage is a service for storing messages that can be accessed from anywhere in the world.</span></span> <span data-ttu-id="5574d-223">单个邮件的大小可以为 64 KB, 并且队列中包含的邮件&mdash;数可以达到定义的存储帐户总容量的多少。</span><span class="sxs-lookup"><span data-stu-id="5574d-223">The size of a single message can be as much as 64 KB, and a queue can contain millions of messages&mdash;up to the total capacity of the storage account in which it is defined.</span></span> <span data-ttu-id="5574d-224">下图显示了在我们的方案中如何使用队列的高级别:</span><span class="sxs-lookup"><span data-stu-id="5574d-224">The following diagram shows at a high level how a queue is used in our scenario:</span></span>

![显示存储队列和两个函数一次推送并将其他弹出邮件发送到队列中的插图](../media/7-q-logical-small.png)

<span data-ttu-id="5574d-226">在这里, 您可以看到新函数, [!INCLUDE [func-name-add](./func-name-add.md)]将邮件添加到队列中。</span><span class="sxs-lookup"><span data-stu-id="5574d-226">Here you can see that the new function, [!INCLUDE [func-name-add](./func-name-add.md)], adds messages to a queue.</span></span> <span data-ttu-id="5574d-227">另一个&mdash;函数例如, 名为 gen- *qr 码*&mdash;的假想函数将从同一队列中弹出消息, 并处理该请求。</span><span class="sxs-lookup"><span data-stu-id="5574d-227">Another function&mdash;for example, a fictitious function called *gen-qr-code*&mdash;will pop messages from the same queue and process the request.</span></span>  <span data-ttu-id="5574d-228">从向队列中写入或*推送*邮件以来, 我们将[!INCLUDE [func-name-add](./func-name-add.md)]向您的解决方案中添加新的输出绑定。</span><span class="sxs-lookup"><span data-stu-id="5574d-228">Since we write, or *push*, messages to the queue from [!INCLUDE [func-name-add](./func-name-add.md)], we'll add a new output binding to your solution.</span></span> <span data-ttu-id="5574d-229">现在, 让我们通过门户 UI 创建绑定。</span><span class="sxs-lookup"><span data-stu-id="5574d-229">Let's create the binding through the portal UI this time.</span></span>

1. <span data-ttu-id="5574d-230">再次选择左侧函数菜单中的 "**集成**" 以打开 "集成" 选项卡。</span><span class="sxs-lookup"><span data-stu-id="5574d-230">Once again, select **Integrate** in the left function menu to open the integration tab.</span></span>

1. <span data-ttu-id="5574d-231">在 "**输出**" 列中选择 "**新输出**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-231">Select **New Output** in the **Outputs** column.</span></span>
    <span data-ttu-id="5574d-232">将显示所有可能的输出绑定类型的列表。</span><span class="sxs-lookup"><span data-stu-id="5574d-232">A list of all possible output binding types is displayed.</span></span>

1. <span data-ttu-id="5574d-233">在列表中, 选择 " **Azure 队列存储**", 然后选择 "**选择**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-233">In the list, select **Azure Queue Storage**, then select **Select**.</span></span>
    <span data-ttu-id="5574d-234">此操作将打开 "Azure 队列存储输出配置" 页。</span><span class="sxs-lookup"><span data-stu-id="5574d-234">This action opens the Azure Queue Storage output configuration page.</span></span>

   <span data-ttu-id="5574d-235">接下来, 我们将设置存储帐户连接。</span><span class="sxs-lookup"><span data-stu-id="5574d-235">Next, we'll set up a storage account connection.</span></span> <span data-ttu-id="5574d-236">这是将托管队列的位置。</span><span class="sxs-lookup"><span data-stu-id="5574d-236">This is where our queue will be hosted.</span></span>
1. <span data-ttu-id="5574d-237">如果出现一条消息, 要求您安装 Microsoft Azure web 作业扩展, 请选择 "**安装**并等待其完成"。</span><span class="sxs-lookup"><span data-stu-id="5574d-237">If a message appears asking  you to install the Microsoft.Azure.WebJobs.Extensions.Storage extension, select **install** and wait for it to finish.</span></span> 

4. <span data-ttu-id="5574d-238">在 "**存储帐户连接**" 字段的右侧, 选择 "**新建**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-238">To the right of the **Storage account connection** field, select **new**.</span></span>
   <span data-ttu-id="5574d-239">将打开 "**存储帐户**选择" 窗格。</span><span class="sxs-lookup"><span data-stu-id="5574d-239">The **Storage Account** selection pane opens.</span></span>

5. <span data-ttu-id="5574d-240">当我们启动此模块并创建了 function app 时, 也会在此时创建一个存储帐户。</span><span class="sxs-lookup"><span data-stu-id="5574d-240">When we started this module and you created your function app, a storage account was also created at that time.</span></span> <span data-ttu-id="5574d-241">它在此窗格中列出, 因此将其选中。</span><span class="sxs-lookup"><span data-stu-id="5574d-241">It's listed in this pane, so select it.</span></span> <span data-ttu-id="5574d-242">"**存储帐户连接**" 字段中填入了一个连接的名称。</span><span class="sxs-lookup"><span data-stu-id="5574d-242">The **Storage account connection** field is populated with the name of a connection.</span></span> <span data-ttu-id="5574d-243">如果要查看连接字符串值, 请选择 "**显示值**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-243">If you want to see the connection string value, select **show value**.</span></span>

6. <span data-ttu-id="5574d-244">尽管我们可以保留所有其他字段中的默认值, 但让我们更改以下内容以更好地表示属性:</span><span class="sxs-lookup"><span data-stu-id="5574d-244">Although we could keep the default values in all the other fields, let's change the following to lend more meaning to the properties:</span></span>

    |<span data-ttu-id="5574d-245">属性</span><span class="sxs-lookup"><span data-stu-id="5574d-245">Property</span></span>  |<span data-ttu-id="5574d-246">旧值</span><span class="sxs-lookup"><span data-stu-id="5574d-246">Old value</span></span>  |<span data-ttu-id="5574d-247">新值</span><span class="sxs-lookup"><span data-stu-id="5574d-247">New value</span></span>  | <span data-ttu-id="5574d-248">说明</span><span class="sxs-lookup"><span data-stu-id="5574d-248">Description</span></span> |
    |---------|---------|---------|---------|
    |<span data-ttu-id="5574d-249">队列名称</span><span class="sxs-lookup"><span data-stu-id="5574d-249">Queue name</span></span>     |    <span data-ttu-id="5574d-250">outqueue</span><span class="sxs-lookup"><span data-stu-id="5574d-250">outqueue</span></span>     |  <span data-ttu-id="5574d-251">**书签-进程后**</span><span class="sxs-lookup"><span data-stu-id="5574d-251">**bookmarks-post-process**</span></span>      | <span data-ttu-id="5574d-252">放置书签的队列的名称, 以便其他函数可以对其进行进一步处理。</span><span class="sxs-lookup"><span data-stu-id="5574d-252">The name of the queue where we're placing bookmarks so that they can be processed further by another function.</span></span> |
    | <span data-ttu-id="5574d-253">消息参数名称</span><span class="sxs-lookup"><span data-stu-id="5574d-253">Message parameter name</span></span>    |  <span data-ttu-id="5574d-254">outputQueueItem</span><span class="sxs-lookup"><span data-stu-id="5574d-254">outputQueueItem</span></span>       |   <span data-ttu-id="5574d-255">**newmessage**</span><span class="sxs-lookup"><span data-stu-id="5574d-255">**newmessage**</span></span>      | <span data-ttu-id="5574d-256">我们将在代码中使用的绑定属性。</span><span class="sxs-lookup"><span data-stu-id="5574d-256">The binding property we'll use in code.</span></span> |

7. <span data-ttu-id="5574d-257">请记住, 选择 "**保存**" 以保存所做的更改。</span><span class="sxs-lookup"><span data-stu-id="5574d-257">Remember to select **Save** to save your changes.</span></span>

## <a name="update-function-implementation"></a><span data-ttu-id="5574d-258">更新函数实现</span><span class="sxs-lookup"><span data-stu-id="5574d-258">Update function implementation</span></span>

<span data-ttu-id="5574d-259">现在, 我们已为该[!INCLUDE [func-name-add](./func-name-add.md)]函数设置了所有绑定。</span><span class="sxs-lookup"><span data-stu-id="5574d-259">We now have all our bindings set up for the [!INCLUDE [func-name-add](./func-name-add.md)] function.</span></span> <span data-ttu-id="5574d-260">现在是在函数中使用它们。</span><span class="sxs-lookup"><span data-stu-id="5574d-260">It's time to use them in our function.</span></span>

1.  <span data-ttu-id="5574d-261">选择函数 "" [!INCLUDE [func-name-add](./func-name-add.md)], 在代码编辑器中打开 " **index .js** " 文件。</span><span class="sxs-lookup"><span data-stu-id="5574d-261">Select your function, [!INCLUDE [func-name-add](./func-name-add.md)], to open the **index.js** file in the code editor.</span></span>

2. <span data-ttu-id="5574d-262">将*索引 .js*文件中的所有代码替换为以下代码段中的代码, 然后**保存**:</span><span class="sxs-lookup"><span data-stu-id="5574d-262">Replace all the code in the *index.js* file with the code from the following snippet and then **Save**:</span></span>

   [!code-javascript[](../code/add-bookmark.js)]

<span data-ttu-id="5574d-263">让我们分解一下此代码执行的操作:</span><span class="sxs-lookup"><span data-stu-id="5574d-263">Let's break down what this code does:</span></span>

* <span data-ttu-id="5574d-264">由于此函数会更改数据, 因此, 我们预期 HTTP 请求是 POST, 并且书签数据是请求正文的一部分。</span><span class="sxs-lookup"><span data-stu-id="5574d-264">Because this function changes our data, we expect the HTTP request to be a POST and the bookmark data to be part of the request body.</span></span>
* <span data-ttu-id="5574d-265">我们的 Azure Cosmos DB 输入绑定尝试使用我们收到的`id`来检索文档或书签。</span><span class="sxs-lookup"><span data-stu-id="5574d-265">Our Azure Cosmos DB input binding attempts to retrieve a document, or bookmark, by using the `id` that we receive.</span></span> <span data-ttu-id="5574d-266">如果找到了一个条目, 则`bookmark`将设置该对象。</span><span class="sxs-lookup"><span data-stu-id="5574d-266">If it finds an entry, the `bookmark` object will be set.</span></span> <span data-ttu-id="5574d-267">`if(bookmark)`条件检查是否找到了条目。</span><span class="sxs-lookup"><span data-stu-id="5574d-267">The `if(bookmark)` condition checks to see whether an entry was found.</span></span>
* <span data-ttu-id="5574d-268">将`context.bindings.newbookmark` binding 参数设置为新书签条目 (我们已将其创建为 JSON 字符串) 就像将 binding 参数添加到数据库中一样简单。</span><span class="sxs-lookup"><span data-stu-id="5574d-268">Adding to the database is as simple as setting the `context.bindings.newbookmark` binding parameter to the new bookmark entry, which we have created as a JSON string.</span></span>
* <span data-ttu-id="5574d-269">将邮件发送到队列就像设置`context.bindings.newmessage`参数一样简单。</span><span class="sxs-lookup"><span data-stu-id="5574d-269">Posting a message to our queue is as simple as setting the  `context.bindings.newmessage` parameter.</span></span>

> [!NOTE]
> <span data-ttu-id="5574d-270">您执行的唯一任务是创建队列绑定。</span><span class="sxs-lookup"><span data-stu-id="5574d-270">The only task you performed was to create a queue binding.</span></span> <span data-ttu-id="5574d-271">您从未显式创建过队列。</span><span class="sxs-lookup"><span data-stu-id="5574d-271">You never created the queue explicitly.</span></span> <span data-ttu-id="5574d-272">您正在 witnessing 绑定的力量!</span><span class="sxs-lookup"><span data-stu-id="5574d-272">You are witnessing the power of bindings!</span></span> <span data-ttu-id="5574d-273">如以下标注所示, 如果不存在, 则自动为您创建队列。</span><span class="sxs-lookup"><span data-stu-id="5574d-273">As the following callout says, the queue is automatically created for you if it doesn't exist.</span></span>

![屏幕截图调出队列将自动创建。](../media/7-q-auto-create-small.png)

<span data-ttu-id="5574d-275">就是这样。</span><span class="sxs-lookup"><span data-stu-id="5574d-275">So, that's it.</span></span> <span data-ttu-id="5574d-276">我们来看下一节中的工作在操作中。</span><span class="sxs-lookup"><span data-stu-id="5574d-276">Let's see our work in action in the next section.</span></span>

## <a name="try-it-out"></a><span data-ttu-id="5574d-277">试用</span><span class="sxs-lookup"><span data-stu-id="5574d-277">Try it out</span></span>

<span data-ttu-id="5574d-278">至此, 我们有多个输出绑定, 测试变得越来越棘手。</span><span class="sxs-lookup"><span data-stu-id="5574d-278">Now that we have multiple output bindings, testing becomes a little trickier.</span></span> <span data-ttu-id="5574d-279">在以前的实验中, 我们通过发送 HTTP 请求和查询字符串来测试要测试的内容, 但现在我们想要执行 http post。</span><span class="sxs-lookup"><span data-stu-id="5574d-279">In previous labs we were content to test by sending an HTTP request and a query string, but we'll want to perform an HTTP post this time.</span></span> <span data-ttu-id="5574d-280">我们还需要检查邮件是否正在将其置于队列中。</span><span class="sxs-lookup"><span data-stu-id="5574d-280">We also need to check to see whether messages are making it into a queue.</span></span>

1. <span data-ttu-id="5574d-281">使用我们的函数[!INCLUDE [func-name-add](./func-name-add.md)], 在函数应用门户中选中, 选择最右侧的测试菜单项以将其展开。</span><span class="sxs-lookup"><span data-stu-id="5574d-281">With our function, [!INCLUDE [func-name-add](./func-name-add.md)], selected in the Function Apps portal, select the Test menu item at the far right to expand it.</span></span>

2. <span data-ttu-id="5574d-282">选择 "**测试**" 菜单项, 并验证是否已打开 "测试" 窗格。</span><span class="sxs-lookup"><span data-stu-id="5574d-282">Select the **Test** menu item, and verify that you have the test pane open.</span></span> <span data-ttu-id="5574d-283">下面的屏幕截图显示了它应如下所示:</span><span class="sxs-lookup"><span data-stu-id="5574d-283">The following screenshot shows what it should look like:</span></span>

    ![显示已展开的函数测试面板的屏幕截图。](../media/7-test-panel-open-small.png)

    > [!IMPORTANT]
    > <span data-ttu-id="5574d-285">确保在 "HTTP 方法" 下拉列表中选择了 "**公告**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-285">Make sure that **POST** is selected in the HTTP method drop-down list.</span></span>

3. <span data-ttu-id="5574d-286">将请求正文的内容替换为以下 JSON 有效负载:</span><span class="sxs-lookup"><span data-stu-id="5574d-286">Replace the content of the request body with the following JSON payload:</span></span>

    ```json
    {
        "id": "docs",
        "url": "https://docs.microsoft.com/azure"
    }
    ```

4. <span data-ttu-id="5574d-287">选择 "测试" 窗格底部的 "**运行**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-287">Select **Run** at the bottom of the test pane.</span></span>

5. <span data-ttu-id="5574d-288">验证 "**输出**" 窗口是否显示 "书签已存在" 消息, 如下图中所示:</span><span class="sxs-lookup"><span data-stu-id="5574d-288">Verify that the **Output** window displays the "Bookmark already exists" message, as shown in the following diagram:</span></span>

    ![显示测试面板和失败的测试结果的屏幕截图。](../media/7-test-exists-small.png)

6. <span data-ttu-id="5574d-290">将请求正文替换为以下有效负载:</span><span class="sxs-lookup"><span data-stu-id="5574d-290">Replace the request body with the following payload:</span></span>

    ```json
    {
        "id": "github",
        "url": "https://www.github.com"
    }
    ```
7. <span data-ttu-id="5574d-291">选择 "测试" 窗格底部的 "**运行**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-291">Select **Run** at the bottom of the test pane.</span></span>

8. <span data-ttu-id="5574d-292">验证 "*输出*" 框是否显示 "添加的书签" 消息, 如下图中所示。</span><span class="sxs-lookup"><span data-stu-id="5574d-292">Verify the that *Output* box displays the "bookmark added" message as shown in the following diagram.</span></span>

    ![显示测试面板和成功测试结果的屏幕截图。](../media/7-test-success-small.png)

<span data-ttu-id="5574d-294">!!</span><span class="sxs-lookup"><span data-stu-id="5574d-294">Congratulations!</span></span> <span data-ttu-id="5574d-295">[!INCLUDE [func-name-add](./func-name-add.md)]工作方式如下所述, 但在代码中有哪些队列操作？</span><span class="sxs-lookup"><span data-stu-id="5574d-295">The [!INCLUDE [func-name-add](./func-name-add.md)] works as designed, but what about that queue operation we had in the code?</span></span> <span data-ttu-id="5574d-296">好, 我们来看看是否有任何内容写入队列。</span><span class="sxs-lookup"><span data-stu-id="5574d-296">Well, let's go see whether something was written to a queue.</span></span>

### <a name="verify-that-a-message-is-written-to-the-queue"></a><span data-ttu-id="5574d-297">验证是否向队列中写入了邮件</span><span class="sxs-lookup"><span data-stu-id="5574d-297">Verify that a message is written to the queue</span></span>

<span data-ttu-id="5574d-298">Azure 队列存储队列托管在存储帐户中。</span><span class="sxs-lookup"><span data-stu-id="5574d-298">Azure Queue Storage queues are hosted in a storage account.</span></span> <span data-ttu-id="5574d-299">创建输出绑定时, 在本练习中已经选择了存储帐户。</span><span class="sxs-lookup"><span data-stu-id="5574d-299">You already selected the storage account in this exercise when you created the output binding.</span></span>

1. <span data-ttu-id="5574d-300">在 Azure 门户的主搜索框中, 键入 "**存储帐户**", 然后在 "**服务**" 下的 "结果" 列表中, 选择 "**存储帐户**"。</span><span class="sxs-lookup"><span data-stu-id="5574d-300">In the main search box in the Azure portal, type **storage accounts**, and in the results list, under **Services**, select **Storage accounts**.</span></span>

      ![在主搜索框中显示存储帐户的搜索结果的屏幕截图。](../media/7-search-for-sa-small.png)

2. <span data-ttu-id="5574d-302">在返回的存储帐户列表中, 选择用于创建**newmessage**输出绑定的存储帐户。</span><span class="sxs-lookup"><span data-stu-id="5574d-302">In the list of storage accounts that are returned, select the storage account that you used to create the **newmessage** output binding.</span></span>
   <span data-ttu-id="5574d-303">存储帐户设置将显示在门户的主窗口中。</span><span class="sxs-lookup"><span data-stu-id="5574d-303">The storage account settings are displayed in the main window of the portal.</span></span>

3. <span data-ttu-id="5574d-304">在 "**服务**" 列表中, 选择 "**队列**" 项目。</span><span class="sxs-lookup"><span data-stu-id="5574d-304">In the **Services** list, select the **Queues** item.</span></span>
   <span data-ttu-id="5574d-305">将显示此存储帐户所承载的队列的列表。</span><span class="sxs-lookup"><span data-stu-id="5574d-305">A list of queues hosted by this storage account is displayed.</span></span> <span data-ttu-id="5574d-306">验证**书签后**的 "书签" 队列是否存在, 如以下屏幕截图所示:</span><span class="sxs-lookup"><span data-stu-id="5574d-306">Verify that the **bookmarks-post-process** queue exists, as shown in the following screenshot:</span></span>

      ![在此存储帐户托管的队列列表中显示队列的屏幕截图](../media/7-q-in-list-small.png)

4. <span data-ttu-id="5574d-308">选择 "**书签-进程后**" 以打开队列。</span><span class="sxs-lookup"><span data-stu-id="5574d-308">Select **bookmarks-post-process** to open the queue.</span></span>
   <span data-ttu-id="5574d-309">队列中的邮件将显示在列表中。</span><span class="sxs-lookup"><span data-stu-id="5574d-309">The messages that are in the queue are displayed in a list.</span></span> <span data-ttu-id="5574d-310">如果所有内容都是按照计划进行的, 则队列包括您在向数据库添加书签时发布的消息。</span><span class="sxs-lookup"><span data-stu-id="5574d-310">If all went according to plan, the queue includes the message that you posted when you added a bookmark to the database.</span></span> <span data-ttu-id="5574d-311">其外观应如下所示:</span><span class="sxs-lookup"><span data-stu-id="5574d-311">It should look like the following:</span></span>

    ![显示队列中的邮件的屏幕截图](../media/7-message-in-q-small.png)

   <span data-ttu-id="5574d-313">在此示例中, 您可以看到该邮件已被提供唯一 ID,**邮件文本**字段以 JSON 字符串格式显示您的书签。</span><span class="sxs-lookup"><span data-stu-id="5574d-313">In this example, you can see that the message was given a unique ID, and the **MESSAGE TEXT** field displays your bookmark in JSON string format.</span></span>

5. <span data-ttu-id="5574d-314">您可以通过在包含新 id/url 集和运行函数的 "测试" 窗格中更改请求正文来进一步测试该函数。</span><span class="sxs-lookup"><span data-stu-id="5574d-314">You can test the function further by changing the request body in the test pane with new id/url sets and running the function.</span></span> <span data-ttu-id="5574d-315">观看此队列以查看更多邮件到达。</span><span class="sxs-lookup"><span data-stu-id="5574d-315">Watch this queue to see more messages arrive.</span></span> <span data-ttu-id="5574d-316">您还可以查看数据库以验证是否已添加新条目。</span><span class="sxs-lookup"><span data-stu-id="5574d-316">You can also look at the database to verify that new entries have been added.</span></span>

<span data-ttu-id="5574d-317">在此实验中, 我们扩展了绑定到输出绑定的知识, 将数据写入 Azure Cosmos DB。</span><span class="sxs-lookup"><span data-stu-id="5574d-317">In this lab, we expanded your knowledge of bindings to output bindings, writing data to your Azure Cosmos DB.</span></span> <span data-ttu-id="5574d-318">我们进一步执行并添加了另一个输出绑定, 以便将邮件发布到 Azure 队列。</span><span class="sxs-lookup"><span data-stu-id="5574d-318">We went further and added another output binding to post messages to an Azure queue.</span></span> <span data-ttu-id="5574d-319">这说明了绑定的真正威力, 可帮助您将数据从传入的源移动并移动到各种目标。</span><span class="sxs-lookup"><span data-stu-id="5574d-319">This demonstrates the true power of bindings to help you shape and move data from incoming sources to a variety of destinations.</span></span> <span data-ttu-id="5574d-320">我们尚未编写任何数据库代码, 也不需要自己管理连接字符串。</span><span class="sxs-lookup"><span data-stu-id="5574d-320">We haven't written any database code or had to manage connection strings ourselves.</span></span> <span data-ttu-id="5574d-321">相反, 我们以声明方式配置绑定, 并让平台处理连接的安全, 扩展我们的功能, 并扩展我们的连接。</span><span class="sxs-lookup"><span data-stu-id="5574d-321">Instead, we configured bindings declaratively and let the platform take care of securing connections, scaling our function, and scaling our connections.</span></span>