<span data-ttu-id="1c37d-101">生成应用程序时, 您希望提供很好的用户体验, 并且其中的一部分是快速数据检索。</span><span class="sxs-lookup"><span data-stu-id="1c37d-101">When building an application, you want to provide a great user experience, and a part of that is quick data retrieval.</span></span> <span data-ttu-id="1c37d-102">从数据库检索数据通常是一个较慢的过程, 如果此数据经常读取, 这可能会带来较差的用户体验。</span><span class="sxs-lookup"><span data-stu-id="1c37d-102">Retrieving data from a database is typically a slow process, and if this data is read often, this could provide a poor user experience.</span></span> <span data-ttu-id="1c37d-103">"正向缓存" 模式介绍了如何将缓存与数据库结合使用, 以尽可能快地返回最常访问的数据。</span><span class="sxs-lookup"><span data-stu-id="1c37d-103">The cache-aside pattern describes how you can implement a cache in conjunction with a database, to return the most commonly accessed data as quickly as possible.</span></span>

<span data-ttu-id="1c37d-104">在这里, 你将了解如何使用带旁缓存的模式来确保你的重要数据能够快速访问。</span><span class="sxs-lookup"><span data-stu-id="1c37d-104">Here, you'll learn how the cache-aside pattern can be used to ensure your important data is quickly accessible.</span></span>

## <a name="what-is-the-cache-aside-pattern"></a><span data-ttu-id="1c37d-105">什么是旁缓存模式？</span><span class="sxs-lookup"><span data-stu-id="1c37d-105">What is the cache-aside pattern?</span></span>

<span data-ttu-id="1c37d-106">旁缓存模式规定, 当您需要从数据源 (如关系数据库) 检索数据时, 应首先检查缓存中的数据。</span><span class="sxs-lookup"><span data-stu-id="1c37d-106">The cache-aside pattern dictates that when you need to retrieve data from a data source, like a relational database, you should first check for the data in your cache.</span></span> <span data-ttu-id="1c37d-107">如果数据在缓存中, 请使用它。</span><span class="sxs-lookup"><span data-stu-id="1c37d-107">If the data is in your cache, use it.</span></span> <span data-ttu-id="1c37d-108">如果数据不在缓存中, 则查询数据库, 并在将数据返回给用户时, 将数据添加到缓存中。</span><span class="sxs-lookup"><span data-stu-id="1c37d-108">If the data is not in your cache, then query the database, and when you're returning the data back to the user, add it to your cache.</span></span> <span data-ttu-id="1c37d-109">这将允许您在下次需要时访问缓存中的数据。</span><span class="sxs-lookup"><span data-stu-id="1c37d-109">This will then allow you to access the data from your cache the next time it's needed.</span></span>

## <a name="when-to-implement-the-cache-aside-pattern"></a><span data-ttu-id="1c37d-110">何时实现与缓存无关的模式？</span><span class="sxs-lookup"><span data-stu-id="1c37d-110">When to implement the cache-aside pattern?</span></span>

<span data-ttu-id="1c37d-111">从数据库读取数据通常是一个较慢的过程。</span><span class="sxs-lookup"><span data-stu-id="1c37d-111">Reading data from a database is usually a slow process.</span></span> <span data-ttu-id="1c37d-112">它涉及编译复杂查询、准备查询执行计划、执行查询, 然后准备结果。</span><span class="sxs-lookup"><span data-stu-id="1c37d-112">It involves compilation of a complex query, preparation of a query execution plan, execution of the query, and then preparation of the result.</span></span> <span data-ttu-id="1c37d-113">在某些情况下, 此过程可能也会从磁盘中读取数据。</span><span class="sxs-lookup"><span data-stu-id="1c37d-113">In some cases, this process may read data from the disk as well.</span></span> <span data-ttu-id="1c37d-114">可以对数据库级别进行优化, 如预编译查询以及将某些数据加载到内存中。</span><span class="sxs-lookup"><span data-stu-id="1c37d-114">There are optimizations that can be done on the database level, like pre-compiling the queries, and loading some of the data in memory.</span></span> <span data-ttu-id="1c37d-115">但是, 在从数据库检索数据时, 执行查询和准备的操作将始终发生。</span><span class="sxs-lookup"><span data-stu-id="1c37d-115">However, execution of the query and preparation of the result will always happen when retrieving data from a database.</span></span>

<span data-ttu-id="1c37d-116">我们可以使用旁向模式解决此问题。</span><span class="sxs-lookup"><span data-stu-id="1c37d-116">We can solve this problem by using the cache-aside pattern.</span></span> <span data-ttu-id="1c37d-117">在旁缓存模式中, 仍有应用程序和数据库, 但现在我们也有缓存。</span><span class="sxs-lookup"><span data-stu-id="1c37d-117">In the cache-aside pattern, we still have the application and the database, but now we also have a cache.</span></span> <span data-ttu-id="1c37d-118">缓存将其数据存储在内存中, 因此无需与文件系统进行交互。</span><span class="sxs-lookup"><span data-stu-id="1c37d-118">A cache stores its data in memory, so it doesn't have to interact with the file system.</span></span> <span data-ttu-id="1c37d-119">缓存还将数据存储在非常简单的数据结构 (如键值对) 中, 因此它们不必在写入数据时执行复杂查询来收集数据或维护索引。</span><span class="sxs-lookup"><span data-stu-id="1c37d-119">Caches also store data in very simple data structures, like key value pairs, so they don't have to execute complex queries to gather data or maintain indexes when writing data.</span></span> <span data-ttu-id="1c37d-120">因此, 缓存通常比数据库的性能更高。</span><span class="sxs-lookup"><span data-stu-id="1c37d-120">Because of this, a cache is typically more performant than a database.</span></span> <span data-ttu-id="1c37d-121">使用应用程序时, 它将首先尝试读取缓存中的数据。</span><span class="sxs-lookup"><span data-stu-id="1c37d-121">When you use an application, it will try to read data from the cache first.</span></span> <span data-ttu-id="1c37d-122">如果请求的数据不在缓存中, 应用程序将从数据库中检索它, 就好像它始终已完成。</span><span class="sxs-lookup"><span data-stu-id="1c37d-122">If the requested data is not in the cache, the application will retrieve it from the database, like it always has done.</span></span> <span data-ttu-id="1c37d-123">但是, 它会将数据存储在缓存中, 以实现后续请求。</span><span class="sxs-lookup"><span data-stu-id="1c37d-123">However, then it stores the data in the cache for subsequent requests.</span></span> <span data-ttu-id="1c37d-124">下次当任何用户请求数据时, 它将直接从缓存中返回。</span><span class="sxs-lookup"><span data-stu-id="1c37d-124">Next time when any user requests the data, it will return it from the cache directly.</span></span>

![将数据加载到缓存的关系图](../media/8-cache-aside-set-cache.png)

### <a name="how-to-manage-updating-data"></a><span data-ttu-id="1c37d-126">如何管理更新数据</span><span class="sxs-lookup"><span data-stu-id="1c37d-126">How to manage updating data</span></span>

<span data-ttu-id="1c37d-127">当您实现与缓存无关的模式时, 会引入一个小问题。</span><span class="sxs-lookup"><span data-stu-id="1c37d-127">When you implement the cache-aside pattern, you introduce a small problem.</span></span> <span data-ttu-id="1c37d-128">由于您的数据现在存储在缓存和数据存储中, 因此当您尝试进行更新时, 您可以遇到问题。</span><span class="sxs-lookup"><span data-stu-id="1c37d-128">Since your data is now stored in a cache and a data store, you can run into problems when you try to make an update.</span></span> <span data-ttu-id="1c37d-129">例如, 若要更新数据, 则需要更新缓存和数据存储区。</span><span class="sxs-lookup"><span data-stu-id="1c37d-129">For example, to update your data, you would need to update both the cache and the data store.</span></span>

<span data-ttu-id="1c37d-130">与备用模式相比, 此问题的解决方案是使缓存中的数据无效。</span><span class="sxs-lookup"><span data-stu-id="1c37d-130">The solution to this problem in the cache-aside pattern is to invalidate the data in the cache.</span></span> <span data-ttu-id="1c37d-131">更新应用程序中的数据时, 应该先删除缓存中的数据, 然后直接对数据源进行更改。</span><span class="sxs-lookup"><span data-stu-id="1c37d-131">When you update data in your application, you should first delete the data in the cache and then make the changes to the data source directly.</span></span> <span data-ttu-id="1c37d-132">这样一来, 在下次请求数据时, 它将不会出现在缓存中, 并且该过程将重复。</span><span class="sxs-lookup"><span data-stu-id="1c37d-132">By doing this, next time the data is requested, it won't be present in the cache, and the process will repeat.</span></span> 

![使缓存数据失效的关系图](../media/8-cache-aside-invalidate.png)

## <a name="considerations-for-using-the-cache-aside-pattern"></a><span data-ttu-id="1c37d-134">使用旁缓存模式的注意事项</span><span class="sxs-lookup"><span data-stu-id="1c37d-134">Considerations for using the cache-aside pattern</span></span>

<span data-ttu-id="1c37d-135">仔细考虑要放入缓存中的数据。</span><span class="sxs-lookup"><span data-stu-id="1c37d-135">Carefully consider which data to put in the cache.</span></span> <span data-ttu-id="1c37d-136">并不是所有数据都适合进行缓存。</span><span class="sxs-lookup"><span data-stu-id="1c37d-136">Not all data is suitable to be cached.</span></span>

- <span data-ttu-id="1c37d-137">**生存时间**: 对于 "缓存", 请确保过期策略与数据的访问频率相匹配。</span><span class="sxs-lookup"><span data-stu-id="1c37d-137">**Lifetime**: For cache-aside to be effective, make sure that the expiration policy matches the access frequency of the data.</span></span> <span data-ttu-id="1c37d-138">使过期时间过短可能会导致应用程序持续检索数据存储区中的数据并将其添加到缓存中。</span><span class="sxs-lookup"><span data-stu-id="1c37d-138">Making the expiration period too short can cause applications to continually retrieve data from the data store and add it to the cache.</span></span>

- <span data-ttu-id="1c37d-139">**逐出**: 与典型数据存储相比, 缓存具有有限的大小, 它们将在必要时逐出数据。</span><span class="sxs-lookup"><span data-stu-id="1c37d-139">**Evicting**: Caches have a limited size compared to typical data stores, and they'll evict data if necessary.</span></span> <span data-ttu-id="1c37d-140">请确保为您的数据选择适当的逐出策略。</span><span class="sxs-lookup"><span data-stu-id="1c37d-140">Make sure you choose an appropriate eviction policy for your data.</span></span>

- <span data-ttu-id="1c37d-141">**Priming**: 若要使备用模式成为有效模式, 许多解决方案将预填充其认为将经常访问的数据的缓存。</span><span class="sxs-lookup"><span data-stu-id="1c37d-141">**Priming**: To make the cache-aside pattern effective, many solutions will prepopulate the cache with data that they think will be accessed often.</span></span>

- <span data-ttu-id="1c37d-142">**一致性**: 实现非缓存模式并不能保证数据存储和缓存之间的一致性。</span><span class="sxs-lookup"><span data-stu-id="1c37d-142">**Consistency**: Implementing the cache-aside pattern doesn't guarantee consistency between the data store and the cache.</span></span> <span data-ttu-id="1c37d-143">可以在不通知缓存的情况下更改数据存储区中的数据。</span><span class="sxs-lookup"><span data-stu-id="1c37d-143">Data in a data store can be changed without notifying the cache.</span></span> <span data-ttu-id="1c37d-144">这可能会导致严重的同步问题。</span><span class="sxs-lookup"><span data-stu-id="1c37d-144">This can lead to serious synchronization issues.</span></span>

<span data-ttu-id="1c37d-145">如果需要从使用磁盘的数据源频繁访问数据, 则 "带缓存" 模式非常有用。</span><span class="sxs-lookup"><span data-stu-id="1c37d-145">The cache-aside pattern is useful when you're required to access data frequently from a data source that uses a disk.</span></span> <span data-ttu-id="1c37d-146">使用带旁缓存的模式, 您将在缓存中存储重要数据, 以帮助提高检索它的速度。</span><span class="sxs-lookup"><span data-stu-id="1c37d-146">Using the cache-aside pattern, you'll store important data in a cache to help increase the speed of retrieving it.</span></span> 