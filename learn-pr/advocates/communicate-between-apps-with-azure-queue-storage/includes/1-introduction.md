<span data-ttu-id="0a451-101">假设您在一个主要的新闻组织中工作, 报告重大新闻通知。</span><span class="sxs-lookup"><span data-stu-id="0a451-101">Imagine you work for a major news organization that reports breaking news alerts.</span></span> <span data-ttu-id="0a451-102">我们的公司使用遍布全球的 journalists, 这些网络会不断通过 web 门户和移动应用程序发送更新。</span><span class="sxs-lookup"><span data-stu-id="0a451-102">Our company employs a worldwide network of journalists that are constantly sending updates through a web portal and a mobile app.</span></span> <span data-ttu-id="0a451-103">然后, 中间层 web 服务层将使用这些警报更新, 并通过几个频道在线发布这些更新。</span><span class="sxs-lookup"><span data-stu-id="0a451-103">A middle tier web service layer then takes those alert updates and publishes them online through several channels.</span></span>

<span data-ttu-id="0a451-104">但是, 当发生全局重大事件时, 系统会丢失警报。</span><span class="sxs-lookup"><span data-stu-id="0a451-104">However, it's been noticed the system is missing alerts when globally significant events occur.</span></span> <span data-ttu-id="0a451-105">这是一个非常_大_的问题, 因为我们的竞争对手是 "scooped"!</span><span class="sxs-lookup"><span data-stu-id="0a451-105">This is a _huge_ problem because we're being "scooped" by our competition!</span></span> <span data-ttu-id="0a451-106">你已手动选择作为公司的首要开发人员, 以确定并解决问题。</span><span class="sxs-lookup"><span data-stu-id="0a451-106">You've been hand-selected as the company's top developer to identify and fix the problem.</span></span>

<span data-ttu-id="0a451-107">中间层提供大量的容量来处理正常负载。</span><span class="sxs-lookup"><span data-stu-id="0a451-107">The middle tier provides plenty of capacity to handle normal loads.</span></span> <span data-ttu-id="0a451-108">但是, 当多个 journalists 尝试同时上载较大的重大情景时, 会发现服务器日志显示系统超载。</span><span class="sxs-lookup"><span data-stu-id="0a451-108">However, a look at the server logs revealed the system was overloaded when several journalists tried to upload larger breaking stories at the same time.</span></span> <span data-ttu-id="0a451-109">有些编写者 complained 门户无法响应, 其他人认为他们完全失去了其故事。</span><span class="sxs-lookup"><span data-stu-id="0a451-109">Some writers complained the portal became unresponsive, and others said they lost their stories altogether.</span></span> <span data-ttu-id="0a451-110">您已发现在中间层服务器上报告的问题和需求峰值之间的直接关系。</span><span class="sxs-lookup"><span data-stu-id="0a451-110">You've spotted a direct correlation between the reported issues and the spike in demand on the middle tier servers.</span></span>

<span data-ttu-id="0a451-111">显然, 您需要一种方法来处理这些意外峰值。</span><span class="sxs-lookup"><span data-stu-id="0a451-111">Clearly, you need a way to handle these unexpected peaks.</span></span> <span data-ttu-id="0a451-112">您不希望添加更多的网站和中间层 web 服务实例, 因为它们成本高昂, 并且在正常情况下是冗余的。</span><span class="sxs-lookup"><span data-stu-id="0a451-112">You don't want to add more instances of the website and middle tier web service because they're expensive and, under normal conditions, redundant.</span></span> <span data-ttu-id="0a451-113">我们可以动态地加速实例, 但这需要一些时间, 我们会在等待新服务器联机时遇到问题。</span><span class="sxs-lookup"><span data-stu-id="0a451-113">We could dynamically spin up instances, but this takes time and we'd have the issue waiting for new servers to come online.</span></span>

<span data-ttu-id="0a451-114">您可以通过使用 Azure 队列存储来解决此问题。</span><span class="sxs-lookup"><span data-stu-id="0a451-114">You can solve this problem by using Azure Queue storage.</span></span> <span data-ttu-id="0a451-115">存储队列是高性能的邮件缓冲区, 可充当前端组件 ("发生器") 和中间层 ("使用者") 之间的代理。</span><span class="sxs-lookup"><span data-stu-id="0a451-115">A storage queue is a high-performance message buffer that can act as a broker between the front-end components (the "producers") and the middle tier (the "consumer").</span></span> 

<span data-ttu-id="0a451-116">我们的前端组件将每个新警报的消息放入队列中。</span><span class="sxs-lookup"><span data-stu-id="0a451-116">Our front-end components place a message for each new alert into a queue.</span></span> <span data-ttu-id="0a451-117">然后, 中间层从队列中一次检索这些消息以进行处理。</span><span class="sxs-lookup"><span data-stu-id="0a451-117">The middle tier then retrieves these messages one at a time from the queue for processing.</span></span> <span data-ttu-id="0a451-118">在需要高需求的情况下, 队列的长度可能会增加, 但不会丢失任何情景, 并且应用程序将保持响应。</span><span class="sxs-lookup"><span data-stu-id="0a451-118">At times of high-demand, the queue may grow in length, but no stories will be lost, and the application will remain responsive.</span></span> <span data-ttu-id="0a451-119">当需求降回到正常水平时, web 服务将通过队列积压工作来追赶。</span><span class="sxs-lookup"><span data-stu-id="0a451-119">When demand drops back to normal levels, the web service will catch up by working through the queue backlog.</span></span>

<span data-ttu-id="0a451-120">我们来了解如何使用 Azure 队列存储来处理高需求, 并提高分布式应用程序的恢复能力。</span><span class="sxs-lookup"><span data-stu-id="0a451-120">Let's learn how to use Azure Queue storage to handle high demand and improve resilience in your distributed applications.</span></span>

## <a name="learning-objectives"></a><span data-ttu-id="0a451-121">学习目标</span><span class="sxs-lookup"><span data-stu-id="0a451-121">Learning objectives</span></span>

- <span data-ttu-id="0a451-122">创建支持队列的 Azure 存储帐户。</span><span class="sxs-lookup"><span data-stu-id="0a451-122">Create an Azure Storage account that supports queues.</span></span>
- <span data-ttu-id="0a451-123">使用 c # 和用于 .net 的 Azure 存储客户端库创建队列。</span><span class="sxs-lookup"><span data-stu-id="0a451-123">Create a queue using C# and the Azure Storage Client Library for .NET.</span></span>
- <span data-ttu-id="0a451-124">使用 c # 和用于 .net 的 Azure 存储客户端库在队列中添加、检索和删除邮件。</span><span class="sxs-lookup"><span data-stu-id="0a451-124">Add, retrieve, and remove messages from a queue using C# and the Azure Storage Client Library for .NET.</span></span>